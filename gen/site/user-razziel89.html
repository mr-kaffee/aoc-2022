<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<title>Solutions by razziel89</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body id="top" class="article toc2 toc-right">
<div id="header">
<h1>Solutions by razziel89</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#sol-1">Day 01: Calorie Counting</a>
<ul class="sectlevel2">
<li><a href="#_oveview">Oveview</a></li>
<li><a href="#_how_to_run">How to run</a></li>
</ul>
</li>
<li><a href="#sol-2">Day 02: Rock Paper Scissors</a>
<ul class="sectlevel2">
<li><a href="#_oveview_2">Oveview</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_how_to_run_2">How to run</a></li>
</ul>
</li>
<li><a href="#sol-3">Day 03: Rucksack Reorganization</a>
<ul class="sectlevel2">
<li><a href="#_oveview_3">Oveview</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_how_to_run_3">How to run</a></li>
</ul>
</li>
<li><a href="#sol-4">Day 04: Camp Cleanup</a>
<ul class="sectlevel2">
<li><a href="#_oveview_4">Oveview</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_how_to_run_4">How to run</a></li>
</ul>
</li>
<li><a href="#sol-5">Day 05: Supply Stacks</a>
<ul class="sectlevel2">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_solution_4">Solution</a></li>
<li><a href="#_how_to_run_5">How to run</a></li>
</ul>
</li>
<li><a href="#sol-6">Day 06: Tuning Trouble</a>
<ul class="sectlevel2">
<li><a href="#_overview_2">Overview</a></li>
<li><a href="#_solution_5">Solution</a></li>
<li><a href="#_how_to_run_6">How to run</a></li>
</ul>
</li>
<li><a href="#sol-7">Day 07: No Space Left On device</a>
<ul class="sectlevel2">
<li><a href="#_oveview_5">Oveview</a></li>
<li><a href="#_solution_6">Solution</a></li>
<li><a href="#_how_to_run_7">How to run</a></li>
</ul>
</li>
<li><a href="#sol-8">Day 08: Treetop Tree House</a>
<ul class="sectlevel2">
<li><a href="#_oveview_6">Oveview</a></li>
<li><a href="#_solution_7">Solution</a></li>
<li><a href="#_how_to_run_8">How to run</a></li>
</ul>
</li>
<li><a href="#sol-9">Day 09: Rope Bridge</a>
<ul class="sectlevel2">
<li><a href="#_oveview_7">Oveview</a></li>
<li><a href="#_solution_8">Solution</a></li>
<li><a href="#_how_to_run_9">How to run</a></li>
</ul>
</li>
<li><a href="#sol-10">Day 10: Cathode-Ray Tube</a>
<ul class="sectlevel2">
<li><a href="#_oveview_8">Oveview</a></li>
<li><a href="#_solution_9">Solution</a></li>
<li><a href="#_how_to_run_10">How to run</a></li>
</ul>
</li>
<li><a href="#sol-11">Day 11: Monkey in the Middle</a>
<ul class="sectlevel2">
<li><a href="#_oveview_9">Oveview</a></li>
<li><a href="#_solution_10">Solution</a></li>
<li><a href="#_how_to_run_11">How to run</a></li>
</ul>
</li>
<li><a href="#sol-12">Day 12: Hill Climbing Algorithm</a>
<ul class="sectlevel2">
<li><a href="#_oveview_10">Oveview</a></li>
<li><a href="#_solution_11">Solution</a></li>
<li><a href="#_how_to_run_12">How to run</a></li>
</ul>
</li>
<li><a href="#sol-13">Day 13: Distress Signal</a>
<ul class="sectlevel2">
<li><a href="#_oveview_11">Oveview</a></li>
<li><a href="#_solution_12">Solution</a></li>
<li><a href="#_how_to_run_13">How to run</a></li>
</ul>
</li>
<li><a href="#sol-14">Day 14: Regolith Reservoir</a>
<ul class="sectlevel2">
<li><a href="#_oveview_12">Oveview</a></li>
<li><a href="#_solution_13">Solution</a></li>
<li><a href="#_how_to_run_14">How to run</a></li>
</ul>
</li>
<li><a href="#sol-15">Day 15: Beacon Exclusion Zone</a>
<ul class="sectlevel2">
<li><a href="#_oveview_13">Oveview</a></li>
<li><a href="#_solution_14">Solution</a></li>
<li><a href="#_how_to_run_15">How to run</a></li>
</ul>
</li>
<li><a href="#sol-16">Day 16: Proboscidea Volcanium</a>
<ul class="sectlevel2">
<li><a href="#_oveview_14">Oveview</a></li>
<li><a href="#_solution_15">Solution</a></li>
<li><a href="#_how_to_run_16">How to run</a></li>
</ul>
</li>
<li><a href="#sol-17">Day 17: Pyroclastic Flow</a>
<ul class="sectlevel2">
<li><a href="#_oveview_15">Oveview</a></li>
<li><a href="#_solution_16">Solution</a></li>
<li><a href="#_how_to_run_17">How to run</a></li>
</ul>
</li>
<li><a href="#sol-18">Day 18: Boiling Boulders</a>
<ul class="sectlevel2">
<li><a href="#_oveview_16">Oveview</a></li>
<li><a href="#_solution_17">Solution</a></li>
<li><a href="#_how_to_run_18">How to run</a></li>
</ul>
</li>
<li><a href="#sol-19">Day 19: Not Enough Minerals</a>
<ul class="sectlevel2">
<li><a href="#_oveview_17">Oveview</a></li>
<li><a href="#_solution_18">Solution</a></li>
<li><a href="#_how_to_run_19">How to run</a></li>
</ul>
</li>
<li><a href="#sol-20">Day 20: Grove Positioning System</a>
<ul class="sectlevel2">
<li><a href="#_oveview_18">Oveview</a></li>
<li><a href="#_solution_19">Solution</a></li>
<li><a href="#_how_to_run_20">How to run</a></li>
</ul>
</li>
<li><a href="#sol-21">Day 21: Monkey Math</a>
<ul class="sectlevel2">
<li><a href="#_oveview_19">Oveview</a></li>
<li><a href="#_solution_20">Solution</a></li>
<li><a href="#_how_to_run_21">How to run</a></li>
</ul>
</li>
<li><a href="#sol-22">Day 22: Monkey Map</a>
<ul class="sectlevel2">
<li><a href="#_oveview_20">Oveview</a></li>
<li><a href="#_solution_21">Solution</a></li>
<li><a href="#_how_to_run_22">How to run</a></li>
</ul>
</li>
<li><a href="#sol-23">Day 23: Unstable Diffusion</a>
<ul class="sectlevel2">
<li><a href="#_oveview_21">Oveview</a></li>
<li><a href="#_solution_22">Solution</a></li>
<li><a href="#_how_to_run_23">How to run</a></li>
</ul>
</li>
<li><a href="#sol-24">Day 24: Blizzard Basin</a>
<ul class="sectlevel2">
<li><a href="#_oveview_22">Oveview</a></li>
<li><a href="#_solution_23">Solution</a></li>
<li><a href="#_how_to_run_24">How to run</a></li>
</ul>
</li>
<li><a href="#sol-25">Day 25: Full of Hot Air</a>
<ul class="sectlevel2">
<li><a href="#_oveview_23">Oveview</a></li>
<li><a href="#_solution_24">Solution</a></li>
<li><a href="#_how_to_run_25">How to run</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="index.html">Overview</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-1">Day 01: Calorie Counting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the calorie counting puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.go</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="k">const</span> <span class="n">NUM_ELVES</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">baggage</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Baggage</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"baggage"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">elves</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nf">baggages_to_elves</span><span class="p">(</span><span class="n">baggage</span><span class="p">);</span>

    <span class="c1">// Elf carrying the most calories will be first in line. It is inefficient to calculate total</span>
    <span class="c1">// calories for every comparison, but it's not really important for this exercise.</span>
    <span class="n">elves</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">el1</span><span class="p">,</span> <span class="n">el2</span><span class="p">|</span> <span class="n">el2</span><span class="nf">.total_calories</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el1</span><span class="nf">.total_calories</span><span class="p">()));</span>

    <span class="k">match</span> <span class="n">elves</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Even though we could solve part 1 if we had 1..=2 elves, we ignore that case here.</span>
        <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"somehow, we found too few elves :("</span><span class="p">)),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Part 1.</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"elf carrying the most is num {} who carries {} calories"</span><span class="p">,</span>
                <span class="n">elves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.get_idx</span><span class="p">(),</span>
                <span class="n">elves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.total_calories</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Part 2.</span>
            <span class="k">let</span> <span class="n">total_calories</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="n">elves</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">NUM_ELVES</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.total_calories</span><span class="p">())</span>
                <span class="nf">.sum</span><span class="p">();</span>

            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"the {} elves carrying the most carry {} in total</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">NUM_ELVES</span><span class="p">,</span> <span class="n">total_calories</span>
            <span class="p">);</span>

            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Baggage</span> <span class="p">{</span>
    <span class="nf">Calories</span><span class="p">(</span><span class="nb">u64</span><span class="p">),</span>
    <span class="n">EndOfElf</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Elf</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">baggage</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Baggage</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Baggage</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">""</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Baggage</span><span class="p">::</span><span class="n">EndOfElf</span><span class="p">),</span>
            <span class="n">val</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Baggage</span><span class="p">::</span><span class="nf">Calories</span><span class="p">(</span><span class="n">val</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Elf</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">total_calories</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.baggage</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
                <span class="nn">Baggage</span><span class="p">::</span><span class="nf">Calories</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
                <span class="nn">Baggage</span><span class="p">::</span><span class="n">EndOfElf</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">})</span>
            <span class="nf">.sum</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_idx</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.idx</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">baggages_to_elves</span><span class="p">(</span><span class="n">baggage</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Baggage</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Elf</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">elves</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">Elf</span> <span class="p">{</span>
        <span class="n">idx</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">baggage</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
    <span class="p">};</span>

    <span class="k">for</span> <span class="n">el</span> <span class="k">in</span> <span class="n">baggage</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
            <span class="nn">Baggage</span><span class="p">::</span><span class="nf">Calories</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">elf</span><span class="py">.baggage</span><span class="nf">.push</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">Baggage</span><span class="p">::</span><span class="n">EndOfElf</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">next_elf</span> <span class="o">=</span> <span class="n">Elf</span> <span class="p">{</span>
                    <span class="n">idx</span><span class="p">:</span> <span class="n">elf</span><span class="py">.idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">baggage</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
                <span class="p">};</span>
                <span class="n">elves</span><span class="nf">.push</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
                <span class="n">elf</span> <span class="o">=</span> <span class="n">next_elf</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">elves</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-2">Day 02: Rock Paper Scissors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the RPS puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_2">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution">Solution</h3>
<div class="paragraph">
<p>This one was pretty straightforward.
I might have taken enums in Rust a bit far, here, but I wanted to use them since
Go, the language used last year, doesn&#8217;t have enums.
I also tried out a custom trait so that I could use generics to determine which
round it was.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="k">fn</span> <span class="n">solve</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">FromStr</span><span class="o">&lt;</span><span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">T</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Round</span><span class="p">,</span>
<span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">rounds</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"rounds"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">round</span> <span class="k">in</span> <span class="n">rounds</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">round_scores</span> <span class="o">=</span> <span class="n">round</span><span class="nf">.score</span><span class="p">();</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span><span class="na">.0</span> <span class="o">+</span> <span class="n">round_scores</span><span class="na">.0</span><span class="p">,</span> <span class="n">scores</span><span class="na">.1</span> <span class="o">+</span> <span class="n">round_scores</span><span class="na">.1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"scores are opponent: {}, you: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">scores</span><span class="na">.0</span><span class="p">,</span> <span class="n">scores</span><span class="na">.1</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.</span>
    <span class="nn">solve</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">RoundPart1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nn">solve</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">RoundPart1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nn">solve</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">RoundPart2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nn">solve</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">RoundPart2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">RPS</span> <span class="p">{</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">P</span><span class="p">,</span>
    <span class="n">S</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Outcome</span> <span class="p">{</span>
    <span class="n">Win</span><span class="p">,</span>
    <span class="n">Loss</span><span class="p">,</span>
    <span class="n">Draw</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This trait is used so that we don't have to care which round we're scoring.</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">Round</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RoundPart1</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">RPS</span><span class="p">,</span>
    <span class="n">me</span><span class="p">:</span> <span class="n">RPS</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RoundPart2</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">RPS</span><span class="p">,</span>
    <span class="n">outcome</span><span class="p">:</span> <span class="n">Outcome</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">RPS</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="c1">// This parser can be used for rounds 1 and 2.</span>
    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"A"</span> <span class="p">|</span> <span class="s">"X"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">),</span>
            <span class="s">"B"</span> <span class="p">|</span> <span class="s">"Y"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">),</span>
            <span class="s">"C"</span> <span class="p">|</span> <span class="s">"Z"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {} as RPS"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Outcome</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"X"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">),</span>
            <span class="s">"Y"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">),</span>
            <span class="s">"Z"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {} as Outcome"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">RoundPart1</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="n">me</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Other error.</span>
                <span class="k">if</span> <span class="o">!</span><span class="p">[</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"B"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">]</span><span class="nf">.contains</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"unknown value {} for other"</span><span class="p">,</span> <span class="n">other</span><span class="p">)))</span>
                <span class="c1">// Me error.</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">!</span><span class="p">[</span><span class="s">"X"</span><span class="p">,</span> <span class="s">"Y"</span><span class="p">,</span> <span class="s">"Z"</span><span class="p">]</span><span class="nf">.contains</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"unknown value {} for me"</span><span class="p">,</span> <span class="n">me</span><span class="p">)))</span>
                <span class="c1">// Success case.</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="n">RoundPart1</span> <span class="p">{</span>
                        <span class="n">other</span><span class="p">:</span> <span class="n">other</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RPS</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                        <span class="n">me</span><span class="p">:</span> <span class="n">me</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RPS</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">RoundPart2</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Other error.</span>
                <span class="k">if</span> <span class="o">!</span><span class="p">[</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"B"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">]</span><span class="nf">.contains</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"unknown value {} for other"</span><span class="p">,</span> <span class="n">other</span><span class="p">)))</span>
                <span class="c1">// Success case.</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="n">RoundPart2</span> <span class="p">{</span>
                        <span class="n">other</span><span class="p">:</span> <span class="n">other</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RPS</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                        <span class="n">outcome</span><span class="p">:</span> <span class="n">result</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Outcome</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Outcome</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">match</span> <span class="o">&amp;</span><span class="k">self</span> <span class="p">{</span>
            <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="p">,</span>
            <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span> <span class="k">=&gt;</span> <span class="mi">6</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RPS</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Needed for round 1. This function could benefit from testing so that we know the result if</span>
    <span class="c1">// called with (a, b) and (b, a) make sense.</span>
    <span class="k">fn</span> <span class="nf">check_win</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RPS</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Outcome</span> <span class="p">{</span>
        <span class="k">match</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Self rock.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">,</span>
            <span class="c1">// Self paper.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">,</span>
            <span class="c1">// Self scissors.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Needed for round 2. This is called on the other's value with a desired outcome.</span>
    <span class="k">fn</span> <span class="nf">get_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Outcome</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RPS</span> <span class="p">{</span>
        <span class="k">match</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Rock.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
            <span class="c1">// Paper.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span>
            <span class="c1">// Scissors.</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Loss</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Draw</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span>
            <span class="p">(</span><span class="nn">RPS</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">Outcome</span><span class="p">::</span><span class="n">Win</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">RPS</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// It turns out we do not need to track the other's score, but we only knew that after the fact...</span>
<span class="k">impl</span> <span class="n">Round</span> <span class="k">for</span> <span class="n">RoundPart1</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="k">self</span><span class="py">.other</span><span class="nf">.score</span><span class="p">()</span> <span class="o">+</span> <span class="k">self</span><span class="py">.other</span><span class="nf">.check_win</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.me</span><span class="p">)</span><span class="nf">.score</span><span class="p">(),</span>
            <span class="k">self</span><span class="py">.me</span><span class="nf">.score</span><span class="p">()</span> <span class="o">+</span> <span class="k">self</span><span class="py">.me</span><span class="nf">.check_win</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.other</span><span class="p">)</span><span class="nf">.score</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Round</span> <span class="k">for</span> <span class="n">RoundPart2</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reply</span> <span class="o">=</span> <span class="k">self</span><span class="py">.other</span><span class="nf">.get_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.outcome</span><span class="p">);</span>
        <span class="p">(</span>
            <span class="k">self</span><span class="py">.other</span><span class="nf">.score</span><span class="p">()</span> <span class="o">+</span> <span class="k">self</span><span class="py">.other</span><span class="nf">.check_win</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span><span class="nf">.score</span><span class="p">(),</span>
            <span class="n">reply</span><span class="nf">.score</span><span class="p">()</span> <span class="o">+</span> <span class="n">reply</span><span class="nf">.check_win</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.other</span><span class="p">)</span><span class="nf">.score</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_2">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-3">Day 03: Rucksack Reorganization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the rucksack reorganization puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_3">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_2">Solution</h3>
<div class="paragraph">
<p>This one was straightforward, but I am not too happy with how the solution
looks.
Working with the <code>HashSet</code> type was not as easy as I thought, e.g. when trying
to compute the overlap of multiple sets.
Furthermore, I somehow misunderstood part 2 at first, which lead me on a wild
goose chase.
Still, this works, but I lack the time to provid more details about the
implementation.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="k">fn</span> <span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
        <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">c</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">c</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">27</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
            <span class="s">"invalid character {} for ord conversion"</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
        <span class="p">))),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">rucksacks</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rucksack</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"rucksack"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>
    <span class="k">let</span> <span class="n">common</span> <span class="o">=</span> <span class="n">rucksacks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="py">.left</span> <span class="o">&amp;</span> <span class="o">&amp;</span><span class="n">el</span><span class="py">.right</span><span class="p">)</span><span class="nf">.into_iter</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">())</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">el</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="nf">ord</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
                    <span class="s">"entry {} has wrong length {}"</span><span class="p">,</span>
                    <span class="n">idx</span><span class="p">,</span>
                    <span class="n">el</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">)))</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">common</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                <span class="n">has_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">has_err</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"encountered at least one error"</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"part 1, total value is {}"</span><span class="p">,</span>
        <span class="n">common</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.flatten</span><span class="p">()</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="k">let</span> <span class="n">badges</span> <span class="o">=</span> <span class="n">rucksacks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.everything</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.chunks_exact</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">sets</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">set3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sets</span> <span class="p">{</span>
                <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">set1</span> <span class="o">&amp;</span> <span class="n">set2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">set3</span><span class="p">)</span><span class="nf">.into_iter</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"this will never happen due to the use of exact_chunk"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">el</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="nf">ord</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
                    <span class="s">"entry {} has wrong length {}"</span><span class="p">,</span>
                    <span class="n">idx</span><span class="p">,</span>
                    <span class="n">el</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">)))</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"part 2, total value is {}"</span><span class="p">,</span>
        <span class="n">badges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.flatten</span><span class="p">()</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Rucksack</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">left</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">right</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rucksack</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">everything</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.left</span> <span class="p">|</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.right</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Rucksack</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">str_to_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">s</span><span class="nf">.len</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">str_to_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="nf">.len</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">..</span><span class="p">]);</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">Rucksack</span> <span class="p">{</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">str_to_set</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">HashSet</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">s</span><span class="nf">.chars</span><span class="p">())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_3">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-4">Day 04: Camp Cleanup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the camp cleanup puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_4">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_3">Solution</h3>
<div class="paragraph">
<p>This one was straightforward, which is why I tried my luck with a generic pair
type.
It worked out nicely as I only had to implemeng the parsing logic once but could
use it for two concrete types.
Then, it was just a matter of creating the methods that compute whether there is
a full (part 1) or partial (part 2) overlap between two ranges and to check for
overlaps in both directions (which is strictly not needed for part 2 but doesn&#8217;t
hurt).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pair</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"pair"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">full_overlaps</span> <span class="o">=</span> <span class="n">pairs</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">if</span> <span class="n">el</span><span class="nf">.full_overlap</span><span class="p">()</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">})</span>
        <span class="nf">.count</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"there are {} full overlaps"</span><span class="p">,</span> <span class="n">full_overlaps</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">partial_overlaps</span> <span class="o">=</span> <span class="n">pairs</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">if</span> <span class="n">el</span><span class="nf">.partial_overlap</span><span class="p">()</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">})</span>
        <span class="nf">.count</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"there are {} partial overlaps"</span><span class="p">,</span> <span class="n">partial_overlaps</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">GenPair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">SEP</span><span class="p">:</span> <span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">left</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">right</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Num</span><span class="p">(</span><span class="nb">usize</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Num</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">(</span><span class="n">s</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">SEP</span><span class="p">:</span> <span class="nb">char</span><span class="o">&gt;</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">GenPair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="p">{</span> <span class="n">SEP</span> <span class="p">}</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">FromStr</span><span class="o">&lt;</span><span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split</span><span class="p">(</span><span class="n">SEP</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">left_str</span><span class="p">,</span> <span class="n">right_str</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">:</span> <span class="n">left_str</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">right</span><span class="p">:</span> <span class="n">right_str</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"cannot parse {} as pair with sep {}"</span><span class="p">,</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">SEP</span>
            <span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Range</span> <span class="o">=</span> <span class="n">GenPair</span><span class="o">&lt;</span><span class="n">Num</span><span class="p">,</span> <span class="sc">'-'</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Pair</span> <span class="o">=</span> <span class="n">GenPair</span><span class="o">&lt;</span><span class="n">Range</span><span class="p">,</span> <span class="sc">','</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Range</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Range</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.left</span><span class="na">.0</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="py">.left</span><span class="na">.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.right</span><span class="na">.0</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="py">.right</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">overlap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Range</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.left</span><span class="na">.0</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="py">.right</span><span class="na">.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.left</span><span class="na">.0</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="py">.left</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">||</span> <span class="p">(</span><span class="k">self</span><span class="py">.right</span><span class="na">.0</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="py">.left</span><span class="na">.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.right</span><span class="na">.0</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="py">.right</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Pair</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">full_overlap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.left</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.right</span><span class="p">)</span> <span class="p">||</span> <span class="k">self</span><span class="py">.right</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.left</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">partial_overlap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.left</span><span class="nf">.overlap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.right</span><span class="p">)</span> <span class="p">||</span> <span class="k">self</span><span class="py">.right</span><span class="nf">.overlap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.left</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_4">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-5">Day 05: Supply Stacks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the supply stacks puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_overview">Overview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_4">Solution</h3>
<div class="paragraph">
<p>Once the inputs have been parsed, this one was straightforward to solve.
You simply have to follow the instructions.
Solving part 2 was particulary nice as I could just pass in a different crate
movement function.
I took the lazy approach for part 2 and implemented it via a temporary stack as
intermediary.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks was a bit harder, on the other hand, because there was no
separator string in place that would make it possible to easily distinguish the
different stacks.
I was tempted to preprocess the input via a shell script or even manually, which
would have simplified parsing.
But then I realised that a filter function each could be used to extract all the
lines belonging to either the stack definition or the definition of movement
instructions.
The use of inexact chunking then made it possible to easily read in the
different stacks.</p>
</div>
<div class="paragraph">
<p>Note that I have used two types to represent stacks: <code>Vec&lt;StackLine&gt;</code>, which is
the type representing the stack input, and <code>Vec&lt;Stack&gt;</code>, which is basically the
transpose of the first type.
Maybe using an actual matrix would have been a beter idea, but this works, too.</p>
</div>
<div class="paragraph">
<p>I noted that many of the terms used in this challenge are reserved words in rust
such as "crate" or "move".</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="k">fn</span> <span class="nf">lines_to_stacks</span><span class="p">(</span><span class="n">lines</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">StackLine</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Stack</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">num_stacks</span><span class="p">)</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.stacks</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.max</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stacks</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">stack_idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">num_stacks</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

            <span class="c1">// We reverse the iterator because we obtained the lines from top to bottom but we need</span>
            <span class="c1">// to build the stacks from the ground up. Thus, we iterate from the ground to the</span>
            <span class="c1">// bottom.</span>
            <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">lines</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// We cannot be sure that every stack line contains the same number of entries.</span>
                <span class="c1">// Thus, we use the ".get" method to be able to catch the case where one line ends</span>
                <span class="c1">// before another. It turns out that every line has the same number of entries,</span>
                <span class="c1">// making this safeguard unnecessary...</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span> <span class="o">=</span> <span class="n">line</span><span class="py">.stacks</span><span class="nf">.get</span><span class="p">(</span><span class="n">stack_idx</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="o">*</span><span class="n">elem</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">stacks</span><span class="nf">.push</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="n">stacks</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"only empty stacks obtained"</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">check_bounds</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
            <span class="s">"{} stack {} is out of bounds"</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">idx</span>
        <span class="p">)));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">apply_move_part1</span><span class="p">(</span><span class="n">stacks</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mov</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Move</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Thanks to these two bounds checks, we know that the index operations below will never panic.</span>
    <span class="nf">check_bounds</span><span class="p">(</span><span class="n">mov</span><span class="py">.src</span><span class="p">,</span> <span class="n">stacks</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"source"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">check_bounds</span><span class="p">(</span><span class="n">mov</span><span class="py">.dest</span><span class="p">,</span> <span class="n">stacks</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"dest"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">mov</span><span class="py">.num</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">moved_elem</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stacks</span><span class="p">[</span><span class="n">mov</span><span class="py">.src</span><span class="p">]</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">stacks</span><span class="p">[</span><span class="n">mov</span><span class="py">.dest</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="o">*</span><span class="n">moved_elem</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot apply move {:?}"</span><span class="p">,</span> <span class="n">mov</span><span class="p">)));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">apply_move_part2</span><span class="p">(</span><span class="n">stacks</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mov</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Move</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Thanks to these two bounds checks, we know that the index operations below will never panic.</span>
    <span class="nf">check_bounds</span><span class="p">(</span><span class="n">mov</span><span class="py">.src</span><span class="p">,</span> <span class="n">stacks</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"source"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">check_bounds</span><span class="p">(</span><span class="n">mov</span><span class="py">.dest</span><span class="p">,</span> <span class="n">stacks</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"dest"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// We are being lazy and are using a temporary stack to stash the crates away. That way, we</span>
    <span class="c1">// keep the order intact when putting them back from the temporary stash to the final stash.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_stack</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">mov</span><span class="py">.num</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">moved_elem</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stacks</span><span class="p">[</span><span class="n">mov</span><span class="py">.src</span><span class="p">]</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">temp_stack</span><span class="nf">.push</span><span class="p">(</span><span class="o">*</span><span class="n">moved_elem</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"cannot apply 1st half of move {:?}"</span><span class="p">,</span>
                <span class="n">mov</span>
            <span class="p">)));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">mov</span><span class="py">.num</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">moved_elem</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">temp_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">stacks</span><span class="p">[</span><span class="n">mov</span><span class="py">.dest</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="o">*</span><span class="n">moved_elem</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"cannot apply 2nd half of move {:?}"</span><span class="p">,</span>
                <span class="n">mov</span>
            <span class="p">)));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">apply_move</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Move</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">moves</span> <span class="o">=</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Move</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"move"</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"move"</span><span class="p">)),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">stack_lines</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">StackLine</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">file</span><span class="p">,</span>
        <span class="s">"stack line"</span><span class="p">,</span>
        <span class="nf">Some</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"["</span><span class="p">)),</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stacks</span> <span class="o">=</span> <span class="nf">lines_to_stacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack_lines</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">mov</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">moves</span> <span class="p">{</span>
        <span class="nf">apply_move</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">stacks</span><span class="p">,</span> <span class="n">mov</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">errs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"the top elements are: {}"</span><span class="p">,</span>
        <span class="n">stacks</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="n">el</span>
                <span class="nf">.last</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.to_string</span><span class="p">())</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"stack {} is empty"</span><span class="p">,</span> <span class="n">idx</span><span class="p">))))</span>
            <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nn">io</span><span class="p">::</span><span class="nf">filter_and_remember_errs</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">errs</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="nf">.join</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="nn">io</span><span class="p">::</span><span class="nf">process_remembered_errs</span><span class="p">(</span><span class="n">errs</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="n">apply_move_part1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="n">apply_move_part1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="n">apply_move_part2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="n">apply_move_part2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Move</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// We are using our own stack type here just so that the code is easier to read.</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Stack</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// This is a temporary data type that we use to parse each line of the top part of the input.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">StackLine</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">stacks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Move</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="s">"move"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s">"from"</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="s">"to"</span><span class="p">,</span> <span class="n">dest</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">num</span><span class="p">:</span> <span class="n">num</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="c1">// We use zero-based indexing but the example uses one-based indxing. Thus, we</span>
                <span class="c1">// convert here.</span>
                <span class="n">src</span><span class="p">:</span> <span class="n">src</span>
                    <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span>
                    <span class="nf">.checked_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{} is not &gt;1"</span><span class="p">,</span> <span class="n">src</span><span class="p">)))</span><span class="o">?</span><span class="p">,</span>
                <span class="n">dest</span><span class="p">:</span> <span class="n">dest</span>
                    <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span>
                    <span class="nf">.checked_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{} is not &gt;1"</span><span class="p">,</span> <span class="n">dest</span><span class="p">)))</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {} as move"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A hybrid between a result and an option.</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Hybrid</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">StackLine</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">errs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">let</span> <span class="n">stacks</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="c1">// Chunking is important here. Each stack entry contains at most 4 characters.</span>
            <span class="c1">// Thus, by chunking this way, we make sure to get exactly one chunk per stack.</span>
            <span class="c1">// Luckily, none of the stacks contains multi-letter crates ^^.</span>
            <span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
                <span class="c1">// Case with data, can be 3 or 4 characters long.</span>
                <span class="p">[</span><span class="sc">'['</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="sc">']'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="sc">'['</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="sc">']'</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nn">Hybrid</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="n">ch</span><span class="nf">.clone</span><span class="p">()),</span>
                <span class="c1">// Case without data.</span>
                <span class="p">[</span><span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">]</span> <span class="p">|</span> <span class="p">[</span><span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">' '</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nn">Hybrid</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span>
                <span class="c1">// Error case.</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nn">Hybrid</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse line {} as stack line"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
            <span class="p">})</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
                <span class="nn">Hybrid</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="nn">Hybrid</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">errs</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">));</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
                <span class="nn">Hybrid</span><span class="p">::</span><span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="nn">io</span><span class="p">::</span><span class="nf">process_remembered_errs</span><span class="p">(</span><span class="n">errs</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="k">Self</span> <span class="p">{</span> <span class="n">stacks</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>io.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="nf">.context</span><span class="p">(</span><span class="s">"reading from disk"</span><span class="p">)</span><span class="o">?</span>
        <span class="nf">.trim_end</span><span class="p">()</span>
        <span class="nf">.split</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Predicate</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Transform</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">parse_lines_to_data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">type_name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">filter</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">transform</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Transform</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">FromStr</span><span class="o">&lt;</span><span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">filter_fn</span> <span class="o">=</span> <span class="n">filter</span><span class="nf">.unwrap_or</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="k">true</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">transformer</span> <span class="o">=</span> <span class="n">transform</span><span class="nf">.unwrap_or</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">errs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="c1">// Read file and convert into actions.</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="nf">.context</span><span class="p">(</span><span class="s">"reading lines"</span><span class="p">)</span><span class="o">?</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">el</span>
                <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span>
                <span class="nf">.with_context</span><span class="p">(||</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse line {} as {}: {}"</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">type_name</span><span class="p">,</span> <span class="n">el</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">errs</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">));</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">errs</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Concatenate errors into one giant error message in case there were any in the file.</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="n">errs</span><span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Convert Result to Option but make sure to add all errors messages to a vector of strings. Use</span>
<span class="c1">// "process_errs" to check whethere there are any errors in the vector.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">filter_and_remember_errs</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">errs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">E</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">match</span> <span class="n">item</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">errs</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">));</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If there is any element in the string vector, concatenate all ements into an error. Do not</span>
<span class="c1">// return an error otherwise.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">process_remembered_errs</span><span class="p">(</span><span class="n">errs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">errs</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Concatenate errors into one giant error message in case there were any in the file.</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="n">errs</span><span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_5">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-6">Day 06: Tuning Trouble</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of the touning trouble puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_overview_2">Overview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_5">Solution</h3>
<div class="paragraph">
<p>For this one, input parsing was non-existent.
Processing, on the other hand, was a bit harder.
At first, I thought about implementing the uniqueness condition manually,
considering that we only had to compare four entries in a pairwise fashion.
I&#8217;m glad I didn&#8217;t do that, though, because of part two.
Instead, it became clear that a set (<code>HashSet</code> in rust) could be used.</p>
</div>
<div class="paragraph">
<p>A set is a collection of unique entris.
Imagine converting a list of somethings into a set of somethings
The only way both the list and the set can have the same number of entries is if
and only if all entries in the list are unique.
That&#8217;s what this code uses.</p>
</div>
<div class="paragraph">
<p>My biggest struggle was rust&#8217;s ownership system and unsatisfied trait bounds
that I didn&#8217;t even know existed.
After the first functioning implementation, I cleaned the code up a bit.
It&#8217;s surprisingly concise.</p>
</div>
<div class="paragraph">
<p>I was happy to have discovered the <code>windows(size)</code> method usable with slices
that produces an iterator over overlapping chunks of <code>size</code> elements.
Now, I only had to check each of them for uniqueness.
That involved some slice-vector-iterator comversions, which appear to be very
common in rust.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">win</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file.</span>
    <span class="k">let</span> <span class="n">lines</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">lines</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">first_match</span> <span class="o">=</span> <span class="n">line</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="nf">.as_slice</span><span class="p">()</span>
            <span class="nf">.windows</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
                <span class="c1">// If the size of a set is equal to the window size, then we have only unique</span>
                <span class="c1">// entries. There is no other way.</span>
                <span class="k">if</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">el</span><span class="nf">.to_vec</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">())</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">win</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="nf">.take</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">.next</span><span class="p">()</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find matching entry"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"first line that fits: {}"</span><span class="p">,</span> <span class="n">first_match</span> <span class="o">+</span> <span class="n">win</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_6">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-7">Day 07: No Space Left On device</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_5">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_6">Solution</h3>
<div class="paragraph">
<p>This solution is not pretty but I kind of messed up a bit at first and then ran
out of time.
A lack of sleep could have contributed.</p>
</div>
<div class="paragraph">
<p>Parsing the input into a native data structure was straightforward thanks to
rust&#8217;s powerful enums.
But then the problems started.
For some reason, I decided to implement a fake directory structure manually as
an excercise and lost a lot of time that way.
As an alternative, I decided to take an idea from rsync&#8217;s cookbook and represent
files and directories a strings but ensure that direcotries always end with a
slash.
That way, I could have one set mapping paths to sizes but could easily determine
whether something was a file or a directory.</p>
</div>
<div class="paragraph">
<p>Then, the process was "just" building such a set of paths, finding all files
under a directory, and applying some operations to that.
I&#8217;m not happy with how the solution turned out but it works.
I was surprised by how much special care is needed when working with the root
directory <code>/</code>.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="c1">// Constants.</span>
<span class="c1">// Part 1.</span>
<span class="k">const</span> <span class="n">MAX_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
<span class="c1">// Part 2.</span>
<span class="k">const</span> <span class="n">TOTAL_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">70000000</span><span class="p">;</span>
<span class="k">const</span> <span class="n">REQUIRED_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">30000000</span><span class="p">;</span>

<span class="c1">// We don'tuse a tree to represent the file system because trees are hard. Instead, we use a map</span>
<span class="c1">// mapping slash-separated strings to size values. An entry ending in a slash is a directory. That</span>
<span class="c1">// way, we can build everything up at once.</span>
<span class="k">fn</span> <span class="nf">build_fs</span><span class="p">(</span><span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Entry</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cwd</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Stack</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">fs</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// This boolean serves as a way to check that we retrieve listed values only after the ls</span>
    <span class="c1">// command has been issued. It's just a sanity check for the input.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">listing</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="n">fs</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"/"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Build up the file system.</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">entry</span> <span class="p">{</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Entry</span><span class="p">::</span><span class="nf">CD</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">listing</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">match</span> <span class="n">dir</span><span class="nf">.as_str</span><span class="p">()</span> <span class="p">{</span>
                    <span class="s">".."</span> <span class="k">=&gt;</span> <span class="n">cwd</span><span class="nf">.popd</span><span class="p">(),</span>
                    <span class="s">"/"</span> <span class="k">=&gt;</span> <span class="n">cwd</span><span class="nf">.clear</span><span class="p">(),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">cwd</span><span class="nf">.pushd</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="c1">// Entries with a trailing slash are directories.</span>
                <span class="k">let</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">cwd</span><span class="nf">.pwd</span><span class="p">();</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">fs</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">fs</span><span class="nf">.insert</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Entry</span><span class="p">::</span><span class="n">LS</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">listing</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Entry</span><span class="p">::</span><span class="nf">DIR</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">listing</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"found dir entry but not not in list mode"</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="c1">// Entries with a trailing slash are directories.</span>
                <span class="n">fs</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}/"</span><span class="p">,</span> <span class="n">cwd</span><span class="nf">.pwd</span><span class="p">(),</span> <span class="n">dir</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Entry</span><span class="p">::</span><span class="nb">FILE</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">listing</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"found file entry but not not in list mode"</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">cwd</span><span class="nf">.pwd</span><span class="p">();</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">fs</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"missing parent node {}"</span><span class="p">,</span> <span class="n">dir</span><span class="p">)));</span>
                <span class="p">}</span>
                <span class="c1">// Entries without a trailing slash are files.</span>
                <span class="n">fs</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
                <span class="c1">// Add directory sizes.</span>
                <span class="k">for</span> <span class="n">dir</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cwd</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">fs</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">)</span>
                        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot read directory {}"</span><span class="p">,</span> <span class="n">dir</span><span class="p">)))</span><span class="o">?</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Entry</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"entry"</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">filesystem</span> <span class="o">=</span> <span class="nf">build_fs</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>
    <span class="k">let</span> <span class="n">result_part1</span> <span class="o">=</span> <span class="n">filesystem</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">name</span><span class="nf">.ends_with</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="n">MAX_SIZE</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"requested size is {}"</span><span class="p">,</span> <span class="n">result_part1</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// We already accumulated sizes, so getting this is easy. The amount of free space is the total</span>
    <span class="c1">// size minus what we currently occupy, which is the size of the root directory.</span>
    <span class="c1">// Note the use of checked_sub here because I wanted to try it out for subtracting from</span>
    <span class="c1">// unsigned values. Those checked_* methods allow graceful handling of overflows. Without them,</span>
    <span class="c1">// rust would panic if there was a violation of a type's value range.</span>
    <span class="k">let</span> <span class="n">used_space</span> <span class="o">=</span> <span class="o">*</span><span class="n">filesystem</span>
        <span class="nf">.get</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot retrieve used space"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">free_space</span> <span class="o">=</span> <span class="n">TOTAL_SIZE</span>
        <span class="nf">.checked_sub</span><span class="p">(</span><span class="n">used_space</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot compute free space"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">required_space</span> <span class="o">=</span> <span class="n">REQUIRED_SIZE</span>
        <span class="nf">.checked_sub</span><span class="p">(</span><span class="n">free_space</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot compute required space"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"need to free up at least {}"</span><span class="p">,</span> <span class="n">required_space</span><span class="p">);</span>

    <span class="c1">// Find the smallest directory that fulfils that condition.</span>
    <span class="k">let</span> <span class="n">min_free_size</span> <span class="o">=</span> <span class="n">filesystem</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">name</span><span class="nf">.ends_with</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="o">&amp;</span><span class="n">required_space</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find any directory for part 2"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"freeing {} is enough"</span><span class="p">,</span> <span class="n">min_free_size</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Entry</span> <span class="p">{</span>
    <span class="nf">CD</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="n">LS</span><span class="p">,</span>
    <span class="nf">DIR</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nb">FILE</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">},</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Entry</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="s">"$"</span><span class="p">,</span> <span class="s">"cd"</span><span class="p">,</span> <span class="n">dir</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">CD</span><span class="p">(</span><span class="n">dir</span><span class="nf">.to_string</span><span class="p">())),</span>
            <span class="p">[</span><span class="s">"$"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">LS</span><span class="p">),</span>
            <span class="p">[</span><span class="s">"dir"</span><span class="p">,</span> <span class="n">dir</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">DIR</span><span class="p">(</span><span class="n">dir</span><span class="nf">.to_string</span><span class="p">())),</span>
            <span class="p">[</span><span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nb">FILE</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">size</span><span class="p">:</span> <span class="n">size</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"canot parse {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Stack</span> <span class="p">{</span>
    <span class="n">it_idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Stack</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">it_idx</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pwd</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.entries</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="s">"/"</span><span class="nf">.to_string</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"/{}/"</span><span class="p">,</span> <span class="k">self</span><span class="py">.entries</span><span class="nf">.join</span><span class="p">(</span><span class="s">"/"</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pushd</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">dir</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.entries</span><span class="nf">.push</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">popd</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Ignore this here.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="k">self</span><span class="py">.entries</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.entries</span><span class="nf">.clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">Stack</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.it_idx</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.entries</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.it_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.it_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.it_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="s">"/"</span><span class="nf">.to_string</span><span class="p">())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.it_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"/{}/"</span><span class="p">,</span> <span class="k">self</span><span class="py">.entries</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.it_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.join</span><span class="p">(</span><span class="s">"/"</span><span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This time, I&#8217;ve even added some tests for some helper functions.
Those tests lets me ensure that any special handling of the root direcotry works
as intended.
Adding tests to a file in rust was pretty easy and a nice experience.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_7">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-8">Day 08: Treetop Tree House</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_6">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_7">Solution</h3>
<div class="paragraph">
<p>I decided not to go the obvious route and use a <code>HashMap</code> mapping tree positions
to tree sizes instead.
I also increased all tree sizes by one so that I could use unsigned numbers for
tree sizes but still include the smallest trees.</p>
</div>
<div class="paragraph">
<p>The main part of this solution is a function that checks which trees are visible
and returns a <code>HashSet</code> of the positions of all visible trees.
I can then take the union of those sets to solve part 1.
The aforementioned function can scan several parallel lines one after the other.
The nice thing about using a <code>HashSet</code> is that I don&#8217;t have to cocern myself
with edges.
I can simply retrieve values until I can find none after displacing the checked
position and then stop iterating.</p>
</div>
<div class="paragraph">
<p>For part 2, I use the same function but modify the visibility condition.
That is, the maximum allowed height is that of the tree I look at.
Furthermore, we accept all trees smaller than our current tree.
I find that unrealistic, which caused some delay.
Imagine this (the tree height is at the top and the index at the bottom):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>4 3 3 1 4

|       |
| | |   |
| | |   |
| | | | |
0 1 2 3 4</pre>
</div>
</div>
<div class="paragraph">
<p>Tree 0 is the one we&#8217;re looking at.
For part 2, this would mean there are 4 trees visible from 0, namely 1, 2, 3,
and 4.
But, in my view, tree 3 is covered by trees 1 and 2 and should not be visible.
Anyway.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="c1">// Count trees visible in a direction count_disp from all positions that can be reached from</span>
<span class="c1">// start_pos + n * outer_disp for all n that still yield a tree. If outer_disp is None, use only</span>
<span class="c1">// n==0. The search stops at the latest if no more trees can be found in that direction, assuming a</span>
<span class="c1">// dense forest.</span>
<span class="c1">//</span>
<span class="c1">// Whether a tree still counts as visible is defined by size_cmp. For part 1, it compares the</span>
<span class="c1">// current tree's size with the size of the largest tree found so far. For part 2, it always</span>
<span class="c1">// returns true because max_height has been set to that of the tree in consideration.</span>
<span class="c1">//</span>
<span class="c1">// A search in one direction stops early after a tree of max_height has been found because no trees</span>
<span class="c1">// behind it can be visible. The value for max_height differs between parts 1 and 2. For part 1,</span>
<span class="c1">// it's the global maximum and for part 2 it's the size of the tree in consideration.</span>
<span class="k">fn</span> <span class="nf">count_visible</span><span class="p">(</span>
    <span class="n">forest</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">),</span> <span class="nn">data</span><span class="p">::</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">start_pos</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="p">,</span>
    <span class="n">count_disp</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="p">,</span>
    <span class="n">outer_disp</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">max_height</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="p">,</span>
    <span class="n">size_cmp</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">u8</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">visible_forest</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">outer_start</span> <span class="o">=</span> <span class="n">start_pos</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="c1">// This will automatically stop if we cannot retrieve any more trees. Assuming a dense forest,</span>
    <span class="c1">// that means once we reached the edge.</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">forest</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outer_start</span><span class="nf">.pos</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">outer_start</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="o">&amp;</span><span class="n">largest</span> <span class="o">&lt;</span> <span class="n">max_height</span> <span class="o">&amp;&amp;</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">=</span> <span class="n">forest</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="nf">.pos</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">tree</span><span class="nf">.size</span><span class="p">();</span>
            <span class="c1">// Remember the positions of trees that pass the size condition.</span>
            <span class="k">if</span> <span class="nf">size_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">visible_forest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pos</span><span class="nf">.pos</span><span class="p">());</span>
                <span class="n">largest</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count_disp</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// If we want to search in the same direction from different starting positions, update the</span>
        <span class="c1">// starting position and go on searching. If not, end the outer loop early.</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span> <span class="o">=</span> <span class="n">outer_disp</span> <span class="p">{</span>
            <span class="n">outer_start</span> <span class="o">=</span> <span class="n">outer_start</span><span class="nf">.add</span><span class="p">(</span><span class="n">disp</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">visible_forest</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">forest</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chars_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"tree"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>
    <span class="c1">// Get dimensions of forest in all three directions. That could have been avoided by using some</span>
    <span class="c1">// matrix structure but I wanted to use a HashMap here, so this is necessary.</span>
    <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">forest</span>
        <span class="nf">.keys</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find max x index"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">forest</span>
        <span class="nf">.keys</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.1</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find max y index"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_height</span> <span class="o">=</span> <span class="n">forest</span>
        <span class="nf">.values</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.size</span><span class="p">())</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find max height"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Compute union of all visible forests (or rather, tree positions).</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Top border rightwards.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">count</span>
        <span class="p">|</span> <span class="o">&amp;</span><span class="nf">count_visible</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">forest</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="o">&amp;</span><span class="n">max_height</span><span class="p">,</span>
            <span class="p">|</span><span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">|</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="c1">// Left border downwards.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">count</span>
        <span class="p">|</span> <span class="o">&amp;</span><span class="nf">count_visible</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">forest</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="o">&amp;</span><span class="n">max_height</span><span class="p">,</span>
            <span class="p">|</span><span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">|</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="c1">// Bottom border rightwards.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">count</span>
        <span class="p">|</span> <span class="o">&amp;</span><span class="nf">count_visible</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">forest</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_y</span><span class="p">),</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="o">&amp;</span><span class="n">max_height</span><span class="p">,</span>
            <span class="p">|</span><span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">|</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="c1">// Right border downwards.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">count</span>
        <span class="p">|</span> <span class="o">&amp;</span><span class="nf">count_visible</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">forest</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="o">&amp;</span><span class="n">max_height</span><span class="p">,</span>
            <span class="p">|</span><span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">|</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">,</span>
        <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"visible are {} trees"</span><span class="p">,</span> <span class="n">count</span><span class="nf">.len</span><span class="p">());</span>

    <span class="c1">// Part 2.</span>
    <span class="k">let</span> <span class="n">disps</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">];</span>

    <span class="k">let</span> <span class="n">best_view</span> <span class="o">=</span> <span class="n">forest</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="n">height</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">disps</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">disp</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">tree_pos</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pos</span><span class="na">.0</span><span class="p">,</span> <span class="n">pos</span><span class="na">.1</span><span class="p">);</span>
                    <span class="nf">count_visible</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="n">forest</span><span class="p">,</span>
                        <span class="c1">// Start searching at the first tree in the search direction from the</span>
                        <span class="c1">// starting position.</span>
                        <span class="o">&amp;</span><span class="n">tree_pos</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">),</span>
                        <span class="n">disp</span><span class="p">,</span>
                        <span class="c1">// Don't search along multiple parallel lines.</span>
                        <span class="nb">None</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">height</span><span class="nf">.size</span><span class="p">(),</span>
                        <span class="p">|</span><span class="n">_size</span><span class="p">,</span> <span class="n">_largest</span><span class="p">|</span> <span class="k">true</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="nf">.len</span><span class="p">()</span>
                <span class="p">})</span>
                <span class="c1">// The scenic score for a tree is the product of the number of trees it can see in</span>
                <span class="c1">// every direction.</span>
                <span class="py">.product</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find best view"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"best view is {}"</span><span class="p">,</span> <span class="n">best_view</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Tree</span><span class="p">(</span><span class="nb">u8</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// We increase the size by one to be able to perform simple unsigned size comparisons.</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">(</span>
            <span class="n">s</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span>
                <span class="nf">.checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot increase tree size"</span><span class="p">))</span><span class="o">?</span><span class="p">,</span>
        <span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nb">Vec</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Vec</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pos</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_8">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-9">Day 09: Rope Bridge</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_7">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_8">Solution</h3>
<div class="paragraph">
<p>Solving this was quite a bit of fun!</p>
</div>
<div class="paragraph">
<p>I created a <code>Vec</code> class to represent 2d vectors and was quite happy to have
outsourced a lot of the logic into that class.
For example, the class offers a <code>mv</code> method, which only ever lets it move by one
space, which is a safeguard against trying to move too far at once.
I haven&#8217;t tried moving by more than one space at a time because it seemed overly
complicated.</p>
</div>
<div class="paragraph">
<p>Furthermore, the custom <code>Vec</code> class has an <code>iter</code> method that provides an
iterator over unit-size steps (unit vectors in the sense of the manhattan
metric) that, if followed, ensure the same distance has been traveled as
described by the original vector.
That way, a simple iteration over iterators gave us all the steps we needed.</p>
</div>
<div class="paragraph">
<p>For solving part 2, one problem was borrowing two elements of the rope
simultaneously while one was even borrowed mutably.
That won&#8217;t work in rust.
Instead, I use a temporary variable to keep track of the updated position of the
previous knot in the rope.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also played around with lifetimes a bit.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c1">// Constants.</span>
<span class="c1">// None yet.</span>

<span class="c1">// Define some helper functions that allow easy conversions from an Option&lt;data::Vec&gt; to a</span>
<span class="c1">// Result&lt;data::Vec&gt; because the latter lets us use the question mark operator for unobstrusive</span>
<span class="c1">// error forwarding.</span>
<span class="k">fn</span> <span class="nf">tail</span><span class="p">(</span><span class="n">rope</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">rope</span><span class="nf">.last</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.clone</span><span class="p">())</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot get tail"</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Yeah, playing with lifetimes.</span>
<span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rope</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">rope</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot get element mutably"</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rope</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">rope</span><span class="nf">.get</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot get element"</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {} WITH LENGTH {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">updates</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_lines_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"vec"</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// All knots start at the very same position.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rope</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">data</span><span class="p">::</span><span class="n">NULL_VEC</span><span class="p">;</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">visited_by_tail</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">visited_by_tail</span><span class="nf">.insert</span><span class="p">(</span><span class="nf">tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rope</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

    <span class="c1">// Part 1.</span>
    <span class="c1">// The `iter` method for a vector provides an iterator over a set of unit-size steps that, if</span>
    <span class="c1">// followed, will ensure that we have traveled the entire distance described by the vector.</span>
    <span class="k">for</span> <span class="n">update</span> <span class="k">in</span> <span class="n">updates</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.iter</span><span class="p">())</span><span class="nf">.flatten</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// The mv method will make sure we never move the head farther than one space. This is just</span>
        <span class="c1">// a safeguard for errors in the code.</span>
        <span class="nf">get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rope</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="nf">.mv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">update</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// Remember only the position of the reference vector, which is the head so far. That</span>
        <span class="c1">// involves a clone.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ref_vec</span> <span class="o">=</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rope</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Update all others with reference to their previous entry.</span>
        <span class="k">for</span> <span class="n">knot</span> <span class="k">in</span> <span class="n">rope</span><span class="nf">.iter_mut</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Move the knot with respect to the reference knot, which is always the previous one.</span>
            <span class="o">*</span><span class="n">knot</span> <span class="o">=</span> <span class="n">knot</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_vec</span><span class="nf">.get_tail_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knot</span><span class="p">));</span>
            <span class="c1">// Update the reference knot's position. Because we can only ever borrow one element as</span>
            <span class="c1">// mutable in rust and once we did so, we cannot borrow anything else, we clone it</span>
            <span class="c1">// here. That's inefficient but I couldn't find an easy way around it without resorting</span>
            <span class="c1">// to `unsafe`, which I want to avoid. Sadly, it seems as if `split_at_mut` involves</span>
            <span class="c1">// `unsafe`.</span>
            <span class="n">ref_vec</span> <span class="o">=</span> <span class="o">*</span><span class="n">knot</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">visited_by_tail</span><span class="nf">.insert</span><span class="p">(</span><span class="nf">tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rope</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"the tail visited {} unique spots for a rope of length {}"</span><span class="p">,</span>
        <span class="n">visited_by_tail</span><span class="nf">.len</span><span class="p">(),</span>
        <span class="n">rope</span><span class="nf">.len</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Part 1.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 2.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nb">Vec</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">NULL_VEC</span><span class="p">:</span> <span class="nb">Vec</span> <span class="o">=</span> <span class="nb">Vec</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="nb">Vec</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span>
            <span class="nf">.split_whitespace</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="s">"R"</span><span class="p">,</span> <span class="n">dist</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">dist</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="p">[</span><span class="s">"L"</span><span class="p">,</span> <span class="n">dist</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">dist</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="p">[</span><span class="s">"U"</span><span class="p">,</span> <span class="n">dist</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">dist</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="p">[</span><span class="s">"D"</span><span class="p">,</span> <span class="n">dist</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="n">dist</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {} as vector"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Vec</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Length in infinity metric.</span>
    <span class="k">fn</span> <span class="nf">infinity_len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.x</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="k">self</span><span class="py">.y</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_infinity_unit</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.infinity_len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="c1">// Map to the 2d unit sphere in manhattan metric. The null vector cannot be mapped and, thus,</span>
    <span class="c1">// remains unchanged.</span>
    <span class="k">fn</span> <span class="nf">as_manhattan_unit</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Move the vector exactly one space along one direction.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">mv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">other</span><span class="nf">.is_infinity_unit</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot move by {:?}"</span><span class="p">,</span> <span class="n">other</span><span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Provide an iterator over unit-sized steps (unit in manhattan metric not infinity metric)</span>
    <span class="c1">// that, if followed, describes the same distance traveled as `self`.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_manhattan_unit</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pos</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.as_manhattan_unit</span><span class="p">();</span>
        <span class="c1">// As this is my second time working with a custom iterator, I was not sure how to avoid</span>
        <span class="c1">// cloning here.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">disps</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">while</span> <span class="o">&amp;</span><span class="n">pos</span> <span class="o">!=</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">new_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit</span><span class="p">);</span>
            <span class="n">disps</span><span class="nf">.push</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">new_pos</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">disps</span><span class="nf">.push</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>

        <span class="n">disps</span><span class="nf">.into_iter</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_tail_update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="c1">// We want to update with a unit vector in manhattan metric, but only if that would not</span>
        <span class="c1">// mean that `other` is on the same space as `self`.</span>
        <span class="k">if</span> <span class="o">&amp;</span><span class="n">other</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">diff</span><span class="nf">.as_manhattan_unit</span><span class="p">())</span> <span class="o">==</span> <span class="k">self</span> <span class="p">{</span>
            <span class="n">NULL_VEC</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">diff</span><span class="nf">.as_manhattan_unit</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_9">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-10">Day 10: Cathode-Ray Tube</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_8">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_9">Solution</h3>
<div class="paragraph">
<p>It&#8217;s getting really interesting now.
I quite liked how part 2 didn&#8217;t require you to compute a number or a sequence of
letters but instead required you to render something on screen.
My solution is less nice, but there is not much time on the weekend.</p>
</div>
<div class="paragraph">
<p>Quite early on, I decided to ignore all the weirdness due to a noop taking one
cycle an an addition taking two cycles.
Instead, I moved to a parallel world where each instruction took exactly one
cycle, which meant replacing each 2-cycle addition by a noop followed by a
1-cycle addition.
So far so straightforward.</p>
</div>
<div class="paragraph">
<p>Furthermore, I ignored all the weirdness due to what is at the beginning,
during, or at the end of a cycle, but instead only looked at the register during
each cycle.
I also had my 1-cycle addition act during its cycle instead of at the cycle&#8217;s
end.
I also started cycle counting at 0 instead of 1.</p>
</div>
<div class="paragraph">
<p>To map the register value during a cycle from my ficticious world back to the
world of the puzzle, I only had to add 2 to the cycle count.
That also means my world had no real cycle one, which meant I had to treat that
one separately for part 2.
For part one, in order to look at the value during cycle 20, I had to skip only
the first 18 entries.</p>
</div>
<div class="paragraph">
<p>Today, I learnt that rust really will panic if you try to subtract 1 from an
unsigned value that is 0.
And off-by-one errors really are the two worst types of bugs that plague
software development.
I also played around with closures that move values into them for the first
time.
They are quite useful!</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="p">;</span>
<span class="c1">// Constants.</span>
<span class="k">const</span> <span class="n">WIDTH</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">render</span><span class="p">(</span><span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">fill</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">crt</span><span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">if</span> <span class="o">*</span><span class="n">el</span> <span class="p">{</span> <span class="sc">'#'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">fill</span> <span class="p">};</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ch</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">maybe_draw</span><span class="p">(</span><span class="n">crt</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">reg</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">cycle</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pixel_idx</span> <span class="o">=</span> <span class="n">cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">horizontal_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixel_idx</span> <span class="o">%</span> <span class="n">width</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>

    <span class="c1">// Used to avoid drawing past the edges. It turns out the register value is nice and those</span>
    <span class="c1">// checks would not have been needed.</span>
    <span class="k">let</span> <span class="n">sprite_at_left_edge</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">sprite_at_right_edge</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">width</span> <span class="k">as</span> <span class="nb">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">horizontal_pos</span> <span class="p">{</span>
        <span class="n">crt</span><span class="p">[</span><span class="n">pixel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">horizontal_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sprite_at_right_edge</span> <span class="p">{</span>
        <span class="n">crt</span><span class="p">[</span><span class="n">pixel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">reg</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">horizontal_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sprite_at_left_edge</span> <span class="p">{</span>
        <span class="n">crt</span><span class="p">[</span><span class="n">pixel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function likely performs a lot of allocations that are not needed but it makes the rest of</span>
<span class="c1">// the problem so much easier to solve.</span>
<span class="k">fn</span> <span class="nf">extend</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Op</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Op</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">input</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nb">None</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">(),</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span> <span class="n">el</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">(),</span>
        <span class="p">})</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">fill</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">ops</span> <span class="o">=</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span> <span class="s">"op"</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// We avoid that one-cycle-two-cycle weridness by replacing each addx operation by a noop and</span>
    <span class="c1">// an addx operation that is assumed to take only one cycle.</span>
    <span class="k">let</span> <span class="n">extended_ops</span> <span class="o">=</span> <span class="nf">extend</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">reg_vals</span> <span class="o">=</span> <span class="n">extended_ops</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">reg</span> <span class="o">+=</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nb">None</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Op</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="n">reg</span>
    <span class="p">});</span>

    <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span>
        <span class="c1">// There is a lot of potential for off-by-one errors in this one.</span>
        <span class="c1">//</span>
        <span class="c1">// We skip the first 18 entries here because we want to start with the value during cycle</span>
        <span class="c1">// 20, which is the value after cycle 19, and this solution ignores what happens during the</span>
        <span class="c1">// first cycle, because that is trivial.</span>
        <span class="k">let</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">skipper</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">interesting</span> <span class="o">=</span> <span class="n">reg_vals</span>
            <span class="nf">.skip</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(</span><span class="k">move</span> <span class="p">|(</span><span class="n">step</span><span class="p">,</span> <span class="n">reg</span><span class="p">)|</span> <span class="p">{</span>
                <span class="c1">// Now convert from our weird way of counting to that of the puzzle.</span>
                <span class="c1">// We wanted to skip the first 19 cycles (add skip + 1) and cycle counting starts</span>
                <span class="c1">// at one (add 1).</span>
                <span class="k">let</span> <span class="n">current_cycle</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">skipper</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">skipper</span> <span class="o">%</span> <span class="mi">40</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">reg</span> <span class="o">*</span> <span class="n">current_cycle</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">interesting</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">crt</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="n">WIDTH</span> <span class="o">*</span> <span class="mi">6</span><span class="p">];</span>

        <span class="c1">// We need to handle the first cycle separately because the cycle number used here is</span>
        <span class="c1">// always that of the cycle we are in. During the first cycle, the register has a value of</span>
        <span class="c1">// 1.</span>
        <span class="nf">maybe_draw</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">crt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">);</span>

        <span class="c1">// Here, current_cycle is the cycle we are currently in. Thus, the number is one larger</span>
        <span class="c1">// than what the example shows because the example usually taks about the value after a</span>
        <span class="c1">// cycle but the value during a cycle is important. This also erroneously assumes the</span>
        <span class="c1">// existence 241'th cycle, but that's not really a problem because the value after the</span>
        <span class="c1">// 240'th cycle is the value during the 241th cycle, so it's consistent.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">current_cycle</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="k">in</span> <span class="n">reg_vals</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">step</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">el</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">maybe_draw</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">crt</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">current_cycle</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">render</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crt</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">fill</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Part 1.</span>
    <span class="c1">// The last argument is not important here.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE2</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 2.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE2</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// Use a space as filler for the real solution to make the letters easier to read.</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="sc">' '</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nb">isize</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Op</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span>
            <span class="nf">.split_whitespace</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="s">"noop"</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nb">None</span><span class="p">),</span>
            <span class="p">[</span><span class="s">"addx"</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">)),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot parse {} as op"</span><span class="p">,</span> <span class="n">s</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_10">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-11">Day 11: Monkey in the Middle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_9">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_10">Solution</h3>
<div class="paragraph">
<p>No time to write much.
The code has comments that should explain the solution.
In part 1, you simply have to code what the task says.
In part 2, the realisation helps that you can display any number as <code>c=n*p+m</code> with
<code>n</code> being a natural number.
Then, you can subtract as many multiples of <code>p</code> from <code>c</code> and not change
divisibility conditions, especially since all <code>p</code> are prime numbers here.
If you pick <code>p</code> to the the product of all unique prime numbers against which
divisibility is being checked, you can keep your numbers small.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">monkeys</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Monkey</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"monkey"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">prod_of_div_vals</span> <span class="o">=</span> <span class="n">monkeys</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.get_div</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="py">.product</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">part1</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">monkey</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">monkeys</span> <span class="p">{</span>
            <span class="n">monkey</span><span class="nf">.set_all_divs</span><span class="p">(</span><span class="n">prod_of_div_vals</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">rounds</span> <span class="o">=</span> <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span> <span class="mi">20</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">10_000</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">_round</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">rounds</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">monkey_idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">monkeys</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// println!("check: {:?}", monkeys[monkey_idx]);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">in</span> <span class="n">monkeys</span><span class="p">[</span><span class="n">monkey_idx</span><span class="p">]</span><span class="nf">.inspect_and_toss</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">monkeys</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="nf">.catch</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="c1">// println!("toss:  {:?} &lt;- {}", monkeys[target], item);</span>
            <span class="p">}</span>
            <span class="c1">// println!("\n")</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">monkeys</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">monkey1</span><span class="p">,</span> <span class="n">monkey2</span><span class="p">|</span> <span class="n">monkey1</span><span class="nf">.how_active</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monkey2</span><span class="nf">.how_active</span><span class="p">()));</span>
    <span class="n">monkeys</span><span class="nf">.reverse</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"most active: {} &amp; {}"</span><span class="p">,</span>
        <span class="n">monkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.whoami</span><span class="p">(),</span>
        <span class="n">monkeys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nf">.whoami</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"monkey business is {}"</span><span class="p">,</span>
        <span class="n">monkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.how_active</span><span class="p">()</span> <span class="o">*</span> <span class="n">monkeys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nf">.how_active</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Monkey</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">activity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">items</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">op</span><span class="p">:</span> <span class="n">QuadraticOp</span><span class="p">,</span>
    <span class="n">test</span><span class="p">:</span> <span class="n">DivisitilibytTest</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Monkey</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">inspect_and_toss</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">self</span>
            <span class="py">.items</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">item_val</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.activity</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">new_item_val</span> <span class="o">=</span> <span class="k">self</span><span class="py">.op</span><span class="nf">.apply</span><span class="p">(</span><span class="n">item_val</span><span class="p">);</span>
                <span class="p">(</span><span class="k">self</span><span class="py">.test</span><span class="nf">.which_monkey</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_item_val</span><span class="p">),</span> <span class="n">new_item_val</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.items</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="n">result</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">catch</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.items</span><span class="nf">.push</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">whoami</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.idx</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">how_active</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.activity</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_all_divs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">prod</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.op.prod</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">prod</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_div</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.test.div_val</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// All operations can be realised as a*x^2 + b*x + c</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">QuadraticOp</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">prod</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">QuadraticOp</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.prod</span> <span class="p">{</span>
            <span class="c1">// We update our worry level but don't divide by anything. Instead, to keep the numbers</span>
            <span class="c1">// small and avoid weirdness due to divisibility checks, we take the modulo with</span>
            <span class="c1">// respect to the product of all unique divisibility checks. Doing so never influences</span>
            <span class="c1">// any of the divisibility checks.</span>
            <span class="p">(</span><span class="k">self</span><span class="py">.a</span> <span class="o">*</span> <span class="n">val</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="k">self</span><span class="py">.b</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="k">self</span><span class="py">.c</span><span class="p">)</span> <span class="o">%</span> <span class="n">prod</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// We update our worry level but always divide by 3 in the end. This is for part 1.</span>
            <span class="p">(</span><span class="k">self</span><span class="py">.a</span> <span class="o">*</span> <span class="n">val</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="k">self</span><span class="py">.b</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="k">self</span><span class="py">.c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">DivisitilibytTest</span> <span class="p">{</span>
    <span class="n">div_val</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">true_monkey</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">false_monkey</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DivisitilibytTest</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">which_monkey</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">%</span> <span class="k">self</span><span class="py">.div_val</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.true_monkey</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.false_monkey</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This one is not pretty but it works and correctly reports errors. More context can always be</span>
<span class="c1">// added if there are unexpected errors.</span>
<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Monkey</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nf">.split</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.trim</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"Monkey"</span><span class="p">,</span> <span class="n">idx_str</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">idx_str</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"monkey id"</span><span class="p">)</span><span class="o">?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"canot find monkey id string"</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">maybe_items</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"Starting items"</span><span class="p">,</span> <span class="n">items_str</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nf">.split</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">items_str</span>
                <span class="nf">.split</span><span class="p">(</span><span class="s">", "</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.trim</span><span class="p">()</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">())</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"canot find items line"</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">maybe_items</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.any</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">false</span> <span class="p">})</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse items line"</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// The next line can never panic.</span>
        <span class="k">let</span> <span class="n">items</span> <span class="o">=</span> <span class="n">maybe_items</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"Operation: new "</span><span class="p">,</span> <span class="n">op_str</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nf">.split</span><span class="p">(</span><span class="s">"="</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">match</span> <span class="n">op_str</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
                <span class="p">[</span><span class="s">"old"</span><span class="p">,</span> <span class="s">"*"</span><span class="p">,</span> <span class="s">"old"</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">QuadraticOp</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">c</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">prod</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="p">[</span><span class="s">"old"</span><span class="p">,</span> <span class="s">"*"</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">QuadraticOp</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="n">num</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"multiplier"</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">c</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">prod</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="p">[</span><span class="s">"old"</span><span class="p">,</span> <span class="s">"+"</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">QuadraticOp</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">c</span><span class="p">:</span> <span class="n">num</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"adder"</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">prod</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot build op"</span><span class="p">)),</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find operations line"</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="nf">.context</span><span class="p">(</span><span class="s">"operation"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">div_val</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"Test:"</span><span class="p">,</span> <span class="s">"divisible"</span><span class="p">,</span> <span class="s">"by"</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">val</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"divisibility"</span><span class="p">)</span><span class="o">?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find divisibility line"</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">true_monkey</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"If"</span><span class="p">,</span> <span class="s">"true:"</span><span class="p">,</span> <span class="s">"throw"</span><span class="p">,</span> <span class="s">"to"</span><span class="p">,</span> <span class="s">"monkey"</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">val</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"true monkey"</span><span class="p">)</span><span class="o">?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find true monkey line"</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">false_monkey</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="p">[</span><span class="s">"If"</span><span class="p">,</span> <span class="s">"false:"</span><span class="p">,</span> <span class="s">"throw"</span><span class="p">,</span> <span class="s">"to"</span><span class="p">,</span> <span class="s">"monkey"</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">val</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.context</span><span class="p">(</span><span class="s">"false monkey"</span><span class="p">)</span><span class="o">?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find false monkey line"</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">true_monkey</span> <span class="p">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">false_monkey</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"trying to toss to myself"</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="nf">is_prime</span><span class="p">(</span><span class="n">div_val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"div val is no prime"</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">test</span> <span class="o">=</span> <span class="n">DivisitilibytTest</span> <span class="p">{</span>
            <span class="n">div_val</span><span class="p">,</span>
            <span class="n">true_monkey</span><span class="p">,</span>
            <span class="n">false_monkey</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">activity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">,</span>
            <span class="n">activity</span><span class="p">,</span>
            <span class="n">items</span><span class="p">,</span>
            <span class="n">op</span><span class="p">,</span>
            <span class="n">test</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This is a quick check for being prime.</span>
<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..</span><span class="n">val</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">true</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_11">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-12">Day 12: Hill Climbing Algorithm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_10">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_11">Solution</h3>
<div class="paragraph">
<p>No time to write much.
This might be the most complex puzzle this year so far.</p>
</div>
<div class="paragraph">
<p>Part 1 can be solved by implementing <code>A*</code> on a directed acyclic graph where each
step has unit cost.
Then, have it search for the path from start to finish, making sure to have a
sane heuristic.</p>
</div>
<div class="paragraph">
<p>With a directed acyclic graph, part 2 can be solved very easily by adding a new,
virtual node and connecting it to all nodes of height <code>a</code>.
Then, search for the shortest path from that virtual node to the end and
subtract 1 from the length of the path (the virtual node).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">build_graph</span><span class="p">(</span><span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">Height</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">map</span><span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">neighbours</span> <span class="o">=</span> <span class="n">p</span>
                <span class="nf">.env</span><span class="p">()</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">other_h</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">other_h</span><span class="nf">.height</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="nf">.height</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                            <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nb">None</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="nn">data</span><span class="p">::</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">find_path</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">estimator_fn</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ref_point</span> <span class="o">=</span> <span class="n">end</span><span class="nf">.pos</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">|</span> <span class="nf">estimator_fn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref_point</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">get_node</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">graph</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="nf">.as_node</span><span class="p">())</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"cannot get node {:?}"</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">checkable</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Add starting point to resulting path.</span>
    <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// Add neighbours of starting point to list of checkable values.</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">start</span><span class="nf">.neighbours</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// Estimated costs are the most direct possible connection plus 1, since every step costs</span>
        <span class="c1">// one.</span>
        <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="nf">.pos</span><span class="p">(),</span> <span class="nf">estimator</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)));</span>
        <span class="c1">// connections.insert(neigh_node, (Some(start.pos()), 1));</span>
    <span class="p">}</span>

    <span class="c1">// Search until we added the final node to the path or until there is nothing more to check.</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">checkable</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// Get node with minimum _estimated_ cost.</span>
        <span class="k">let</span> <span class="n">next_best_node</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.iter_mut</span><span class="p">()</span>
            <span class="c1">// Get node with minimum estimated cost.</span>
            <span class="nf">.min_by</span><span class="p">(|(</span><span class="n">_node1</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre1</span><span class="p">,</span> <span class="n">cost1</span><span class="p">)),</span> <span class="p">(</span><span class="n">_node2</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre2</span><span class="p">,</span> <span class="n">cost2</span><span class="p">))|</span> <span class="n">cost1</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cost2</span><span class="p">))</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find next node"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.0</span>
            <span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">predecessor</span><span class="p">,</span> <span class="n">_old_estimate</span><span class="p">))</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.remove_entry</span><span class="p">(</span><span class="n">next_best_node</span><span class="p">)</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find predecessor"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">cost_of_predecessor</span> <span class="o">=</span> <span class="n">connections</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">predecessor</span><span class="nf">.as_node</span><span class="p">())</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"predecessor has not been visited"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.1</span><span class="p">;</span>

        <span class="c1">// Add point to resulting path.</span>
        <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span><span class="n">next_best_node</span><span class="p">,</span> <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">predecessor</span><span class="p">),</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

        <span class="c1">// Add neighbours of point to list of checkable values.</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">next_best_node</span><span class="nf">.neighbours</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">estimate</span> <span class="o">=</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="nf">estimator</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">previous_best</span> <span class="o">=</span> <span class="n">checkable</span>
                    <span class="nf">.get</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
                    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">))</span>
                    <span class="na">.1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">previous_best</span> <span class="o">&gt;</span> <span class="n">estimate</span> <span class="p">{</span>
                    <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">next_best_node</span><span class="nf">.pos</span><span class="p">(),</span> <span class="n">estimate</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="c1">// connections.insert(neigh_node, Some(start.pos()));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">extract_shortest_path</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">points</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">check_node</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="nf">Some</span><span class="p">(</span><span class="n">pre</span><span class="p">),</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="n">points</span><span class="nf">.get</span><span class="p">(</span><span class="n">check_node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">graph</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pre</span><span class="nf">.as_node</span><span class="p">())</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find node in graph"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
        <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="n">check_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">height_map</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chars_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Height</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"vec"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Create graph. To avoid self-referencing data types, we identify each node only by its</span>
    <span class="c1">// position.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">graph</span> <span class="o">=</span> <span class="nf">build_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">height_map</span><span class="p">);</span>

    <span class="c1">// Find start and end nodes. Also adjust heights to use actual values. This is a bit of a pain</span>
    <span class="c1">// in rust...</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">start_node</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.get_height</span><span class="p">()</span> <span class="o">==</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Height</span><span class="p">::</span><span class="n">Start</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find start node"</span><span class="p">))</span><span class="o">?</span>
        <span class="nf">.clone</span><span class="p">();</span>
    <span class="n">start_node</span><span class="nf">.set_height</span><span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="nn">Height</span><span class="p">::</span><span class="nf">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">graph</span>
        <span class="nf">.replace</span><span class="p">(</span><span class="n">start_node</span><span class="nf">.clone</span><span class="p">())</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot replace end node"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">end_node</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.get_height</span><span class="p">()</span> <span class="o">==</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Height</span><span class="p">::</span><span class="n">End</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find end node"</span><span class="p">))</span><span class="o">?</span>
        <span class="nf">.clone</span><span class="p">();</span>
    <span class="n">end_node</span><span class="nf">.set_height</span><span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="nn">Height</span><span class="p">::</span><span class="nf">Normal</span><span class="p">(</span><span class="mi">25</span><span class="p">));</span>
    <span class="n">graph</span>
        <span class="nf">.replace</span><span class="p">(</span><span class="n">end_node</span><span class="nf">.clone</span><span class="p">())</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot replace end node"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="n">node</span><span class="nf">.infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_point</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">extract_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_node</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">))</span><span class="o">??</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"part 1: {}"</span><span class="p">,</span> <span class="n">path</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// Add an additional node at a position that hadn't yet been part of the graph and connect it</span>
    <span class="c1">// to all nodes of zero elevation.</span>
    <span class="k">let</span> <span class="n">possible_starts</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="n">node</span><span class="nf">.get_height</span><span class="p">()</span><span class="nf">.height</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="n">node</span><span class="nf">.pos</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">far_away_fake_node</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span> <span class="p">},</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Height</span><span class="p">::</span><span class="nf">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">possible_starts</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">graph</span><span class="nf">.insert</span><span class="p">(</span><span class="n">far_away_fake_node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span>
            <span class="s">"refusing to overwrite existing node for fake nod"</span><span class="p">,</span>
        <span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">path2</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">extract_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_node</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">))</span><span class="o">??</span><span class="p">;</span>

    <span class="c1">// We have to ignore the first two steps here because of the real and fake start nodes.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"part 2: {}"</span><span class="p">,</span> <span class="n">path2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq,</span> <span class="nd">Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="o">*</span><span class="k">self</span><span class="p">,</span>
            <span class="n">h</span><span class="p">:</span> <span class="nn">Height</span><span class="p">::</span><span class="n">End</span><span class="p">,</span>
            <span class="n">neighbours</span><span class="p">:</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">Debug,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Height</span> <span class="p">{</span>
    <span class="nf">Normal</span><span class="p">(</span><span class="nb">usize</span><span class="p">),</span>
    <span class="n">Start</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Height</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">End</span> <span class="k">=&gt;</span> <span class="mi">25</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Start</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="nf">Normal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This one is not pretty but it works and correctly reports errors. More context can always be</span>
<span class="c1">// added if there are unexpected errors.</span>
<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Height</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
                <span class="s">"S"</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Start</span><span class="p">,</span>
                <span class="s">"E"</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">End</span><span class="p">,</span>
                <span class="c1">// The next line can never panic.</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">Normal</span><span class="p">(</span><span class="n">s</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">),</span>
            <span class="p">})</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"received several characters or none"</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="n">Height</span><span class="p">,</span>
    <span class="n">neighbours</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pos</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">neighbours</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.neighbours</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="n">Height</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">neighbours</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Height</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.h</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">Height</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.h</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="p">((</span><span class="k">self</span><span class="py">.p.x</span> <span class="o">-</span> <span class="n">other</span><span class="py">.x</span><span class="p">)</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="k">self</span><span class="py">.p.y</span> <span class="o">-</span> <span class="n">other</span><span class="py">.y</span><span class="p">)</span><span class="nf">.abs</span><span class="p">())</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// We identify a node only by its position and never by its associated height.</span>
<span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span><span class="nf">.hash</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span> <span class="o">==</span> <span class="n">other</span><span class="py">.p</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_12">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-13">Day 13: Distress Signal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_11">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_12">Solution</h3>
<div class="paragraph">
<p>Input parsing was a pain.
The idea I used is to split each package at the given commas, but to only use
those commas that are at the correct nesting level.
Then, the parser is called again for each individual entry.
Special care has to be taken since there are empty lists, too.</p>
</div>
<div class="paragraph">
<p>This time, I did not try to get around self-referencing data types, which means
I got to use <code>Box&lt;T&gt;</code> for the first time.
It was nicer than expected.
It&#8217;s good to know that Rust will ensure memory safety also for data on the heap.</p>
</div>
<div class="paragraph">
<p>Part 1 was straightforward once the inputs had been parsed.
Luckily, I had decided to create <code>compare</code> methods for each separate data type
(<code>Pkg</code> and <code>Elem</code>) that returned a triplet indicating the ordering.
Thus, in part 2, I could use the very same comparison methods to have Rust sort
the vector of packges.</p>
</div>
<div class="paragraph">
<p>In order to find out the indices of the divider packages but avoid implementing
a comparison operation for packages, I sorted a vector of tuples that contained
a package and a marker.
Once sorted, I could just retrieve the indices of the markers.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"package"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>
    <span class="k">let</span> <span class="n">ordered_correctly</span> <span class="o">=</span> <span class="n">pairs</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">el</span><span class="nf">.is_ordered_correctly</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"correctly ordered: {}"</span><span class="p">,</span> <span class="n">ordered_correctly</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// Create divider packages. We wrote a parser so we might as well use it for easy creation of</span>
    <span class="c1">// the divider packages.</span>
    <span class="k">let</span> <span class="n">div1</span> <span class="o">=</span> <span class="s">"[[2]]"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">div2</span> <span class="o">=</span> <span class="s">"[[6]]"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// A value of "true" means this package is a marker.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">all_pkgs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="kc">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">div1</span><span class="p">),</span> <span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">div2</span><span class="p">)];</span>
    <span class="n">all_pkgs</span><span class="nf">.extend</span><span class="p">(</span>
        <span class="n">pairs</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nd">vec!</span><span class="p">[(</span><span class="kc">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">el</span><span class="py">.left</span><span class="p">),</span> <span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">el</span><span class="py">.right</span><span class="p">)]</span><span class="nf">.into_iter</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Sort using the comparison method created for part 1.</span>
    <span class="n">all_pkgs</span><span class="nf">.sort_by</span><span class="p">(|(</span><span class="n">_marker1</span><span class="p">,</span> <span class="n">pkg1</span><span class="p">),</span> <span class="p">(</span><span class="n">_marker2</span><span class="p">,</span> <span class="n">pkg2</span><span class="p">)|</span> <span class="n">pkg1</span><span class="nf">.compare</span><span class="p">(</span><span class="n">pkg2</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">decoder_key</span> <span class="o">=</span> <span class="n">all_pkgs</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">_pkg</span><span class="p">))|</span> <span class="o">*</span><span class="n">marker</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">_marker</span><span class="p">,</span> <span class="n">_pkg</span><span class="p">))|</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="py">.product</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"decoder key is {}"</span><span class="p">,</span> <span class="n">decoder_key</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Input</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">left</span><span class="p">:</span> <span class="n">Pkg</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">right</span><span class="p">:</span> <span class="n">Pkg</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Pkg</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span><span class="p">);</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Elem</span> <span class="p">{</span>
    <span class="nf">Num</span><span class="p">(</span><span class="nb">isize</span><span class="p">),</span>
    <span class="nf">Dat</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Input</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_ordered_correctly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.left</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.right</span><span class="p">)</span> <span class="o">==</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Pkg</span> <span class="p">{</span>
    <span class="c1">// This is run on the left value with the right value as argument.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="c1">// The zip operator will end the iteration as soon as one of the two iterators runs out.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">other</span><span class="na">.0</span><span class="nf">.iter</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">left</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{}</span>
                <span class="n">ord</span> <span class="o">@</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="p">|</span> <span class="n">ord</span> <span class="o">@</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">ord</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// If we reach here, all value comparisons turned out equal so far. Thus, perform the</span>
        <span class="c1">// length comparison.</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="na">.0</span><span class="nf">.len</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Elem</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="k">match</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If both are numbers, compare the numbers.</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">left</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">right</span><span class="p">),</span>
            <span class="c1">// If both are lists, compare the lists.</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="k">ref</span> <span class="n">left</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="k">ref</span> <span class="n">right</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">left</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">right</span><span class="p">),</span>
            <span class="c1">// If one is a number and the other one is a list, wrap the number in the list and</span>
            <span class="c1">// comapre again.</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="k">ref</span> <span class="n">right</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">Pkg</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">left</span><span class="p">)])</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">right</span><span class="p">),</span>
            <span class="p">(</span><span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="k">ref</span> <span class="n">left</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">left</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">Pkg</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Elem</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">right</span><span class="p">)])),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Input</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.split</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lines</span>
            <span class="nf">.next</span><span class="p">()</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find left line"</span><span class="p">))</span><span class="o">?</span>
            <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lines</span>
            <span class="nf">.next</span><span class="p">()</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find right line"</span><span class="p">))</span><span class="o">?</span>
            <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This one is not pretty but it works and correctly reports errors.</span>
<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Pkg</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nesting_level</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">chars</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">s</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"["</span><span class="p">)</span> <span class="p">||</span> <span class="o">!</span><span class="n">s</span><span class="nf">.ends_with</span><span class="p">(</span><span class="s">"]"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"string is no real package"</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">elems_at_level</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="c1">// Skip the opening bracket and extract all elements at this level of the hierarchy. This</span>
        <span class="c1">// is not pretty but seems to work.</span>
        <span class="k">for</span> <span class="nb">char</span> <span class="k">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">s</span><span class="nf">.len</span><span class="p">()]</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="k">match</span> <span class="nb">char</span> <span class="p">{</span>
                <span class="sc">'['</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Since we skip the very first "[", this indicates the start of a nested list.</span>
                    <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="nb">char</span><span class="p">);</span>
                    <span class="n">nesting_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
                <span class="sc">']'</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">nesting_level</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// Emit what we found so far. This will be the very last element. We use</span>
                        <span class="c1">// this closing bracket to ensure we do emit the very last value.</span>
                        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">chars</span><span class="p">;</span>
                        <span class="n">chars</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// We found the end of a nested list. Remember the current character.</span>
                        <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="nb">char</span><span class="p">);</span>
                        <span class="n">nesting_level</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="nb">None</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="sc">','</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">nesting_level</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// Emit one value. This is one element of the list at this level.</span>
                        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">chars</span><span class="p">;</span>
                        <span class="n">chars</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// We are still not at the top nesting level.</span>
                        <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="nb">char</span><span class="p">);</span>
                        <span class="nb">None</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Remember all other characters.</span>
                    <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="nb">char</span><span class="p">);</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span> <span class="p">{</span>
                <span class="n">elems_at_level</span><span class="nf">.push</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Parse all entries at this level of the hierarchy into "Elem"s. Errors are being handled</span>
        <span class="c1">// further down.</span>
        <span class="k">let</span> <span class="n">maybe_parsed_elems</span> <span class="o">=</span> <span class="n">elems_at_level</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">el</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">maybe_parsed_elems</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span> <span class="p">{</span>
                <span class="n">has_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">has_err</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse package"</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">parsed_elems</span> <span class="o">=</span> <span class="n">maybe_parsed_elems</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="c1">// This line can never panic.</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.unwrap</span><span class="p">())</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

            <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">(</span><span class="n">parsed_elems</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Elem</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">s</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// Empty package.</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Pkg</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]))))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">s</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"["</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This is itself a non-empty package.</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">Dat</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">s</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Pkg</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">)))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Otherwise, this is a number.</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">s</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_13">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-14">Day 14: Regolith Reservoir</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_12">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_13">Solution</h3>
<div class="paragraph">
<p>Today&#8217;s puzzle was rather straightforward.
Just follow each grain of sand on its way down.
I tracked positions of sand that settled via a <code>HashSet</code> to be able to check
whether a position has been occupied very easily.
For the rocks, I went a different route, though.
Expecting some twist in part 2 that would increase the size of the playing field
a lot, I did not fill the positions of rocks into an occupation map.
Instead, I remembered them as one-dimensional ranges and checked whether a point
was on that range.
I have no clue whether that provides better performance than using a set.</p>
</div>
<div class="paragraph">
<p>Today, I learned that the difference between a <code>cargo run</code> and a <code>cargo run
--release</code> in terms of runtime can be a factor of 55!</p>
</div>
<div class="paragraph">
<p>I also wrote a stepwise visualiser.
To use it, set the env var <code>RENDER</code> to <code>1</code> and select the part of the puzzle you
want to run with the env var <code>RUN</code>.
Set the env var <code>RUN</code> to 0, 1, 2, or 3 for the sample part 1, the real puzzle
part 1, the sample part 2, or the real puzzle part 2.
After printing the final resting place of one grain of sand, you have to hit
return to resume.
To get a nicely rendered view, pipe the output of <code>yes</code> into the executable.
Warning: This will tax your CPU quite significantly.
Only run in release more for <code>RUN==3</code>.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c1">// Constants.</span>
<span class="k">const</span> <span class="n">SOURCE</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">fn</span> <span class="nf">is_blocked</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span>
    <span class="n">rocks</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rocks</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">sands</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">max_y</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">sands</span><span class="nf">.get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="py">.y</span> <span class="o">&gt;=</span> <span class="n">bottom</span> <span class="p">{</span>
        <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">rocks</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.any</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.contains</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">render</span><span class="p">(</span>
    <span class="n">rocks</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rocks</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">sands</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">fov</span><span class="p">:</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">),</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">image</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">fov</span><span class="na">.1</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="p">{</span> <span class="n">fov</span><span class="na">.1</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="o">-</span><span class="mi">2</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">min_y</span><span class="o">..</span><span class="n">fov</span><span class="na">.3</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">fov</span><span class="na">.0</span> <span class="o">-</span> <span class="n">dist</span><span class="o">..</span><span class="n">fov</span><span class="na">.2</span> <span class="o">+</span> <span class="n">dist</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">};</span>
            <span class="c1">// This point is a rock.</span>
            <span class="k">let</span> <span class="nb">char</span> <span class="o">=</span> <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">SOURCE</span> <span class="p">{</span>
                <span class="sc">'S'</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">p</span><span class="py">.y</span> <span class="o">==</span> <span class="n">fov</span><span class="na">.3</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="sc">'#'</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">rocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="p">{</span>
                <span class="sc">'#'</span>
            <span class="c1">// This point is sand.</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">rocks</span><span class="p">,</span> <span class="n">sands</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="p">{</span>
                <span class="sc">'.'</span>
            <span class="c1">// This point is free.</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="sc">' '</span>
            <span class="p">};</span>
            <span class="n">image</span><span class="nf">.push</span><span class="p">(</span><span class="nb">char</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">image</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">image</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">is_env</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">def</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">def</span><span class="nf">.to_string</span><span class="p">())</span> <span class="o">==</span> <span class="n">val</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">rocks</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rocks</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"rocks"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Coordinates for rendering. This is just lazy copy-pasting.</span>
    <span class="k">let</span> <span class="n">min_x_rocks</span> <span class="o">=</span> <span class="n">rocks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find xmin"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">min_y_rocks</span> <span class="o">=</span> <span class="n">rocks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find ymin"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_x_rocks</span> <span class="o">=</span> <span class="n">rocks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find xmax"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y_rocks</span> <span class="o">=</span> <span class="n">rocks</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find ymax"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">render_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_x_rocks</span><span class="p">,</span> <span class="n">min_y_rocks</span><span class="p">,</span> <span class="n">max_x_rocks</span><span class="p">,</span> <span class="n">max_y_rocks</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">highest_y</span> <span class="o">=</span> <span class="n">SOURCE</span><span class="py">.y</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span> <span class="n">max_y_rocks</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">max_y_rocks</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">sands</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">blocked_y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">max_y</span><span class="p">)</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">do_render</span> <span class="o">=</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RENDER"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">);</span>

    <span class="c1">// If this condition is no longer fulfilled, a piece of sand has exceeded our world and will</span>
    <span class="c1">// fall to infinity.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Spawn new sand.</span>
        <span class="k">if</span> <span class="n">do_render</span> <span class="p">{</span>
            <span class="c1">// Clear screen and print view.</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\x1b</span><span class="s">c{}"</span><span class="p">,</span> <span class="nf">render</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sands</span><span class="p">,</span> <span class="n">render_coords</span><span class="p">));</span>
            <span class="c1">// Only continue after the user confirmed.</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.next</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sand</span> <span class="o">=</span> <span class="n">SOURCE</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_settled</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">has_settled</span> <span class="o">&amp;&amp;</span> <span class="n">sand</span><span class="py">.y</span> <span class="o">&lt;=</span> <span class="n">max_y</span> <span class="p">{</span>
            <span class="c1">// Find the highest point that contains either sand or is a rock.</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="n">sand</span><span class="nf">.down</span><span class="p">();</span>
            <span class="k">while</span> <span class="o">!</span><span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sands</span><span class="p">,</span> <span class="n">blocked_y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sand</span><span class="py">.y</span> <span class="o">&lt;=</span> <span class="n">max_y</span> <span class="p">{</span>
                <span class="n">sand</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">sand</span><span class="nf">.down</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1">// If we reach here, that piece of sand has hit an occupied tile on its way down.</span>
            <span class="c1">// We don't check again whether we exceeded our world because that will be checked the</span>
            <span class="c1">// nxt time we reach the top of the while loop.</span>
            <span class="c1">//</span>
            <span class="c1">// Check down to the left first.</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">sand</span><span class="nf">.left_down</span><span class="p">();</span>
            <span class="k">if</span> <span class="o">!</span><span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sands</span><span class="p">,</span> <span class="n">blocked_y</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sand</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Check down to the right next.</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">sand</span><span class="nf">.right_down</span><span class="p">();</span>
            <span class="k">if</span> <span class="o">!</span><span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sands</span><span class="p">,</span> <span class="n">blocked_y</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sand</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">has_settled</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">sands</span><span class="nf">.insert</span><span class="p">(</span><span class="n">sand</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">sand</span><span class="py">.y</span> <span class="o">&gt;</span> <span class="n">highest_y</span> <span class="p">{</span>
            <span class="n">highest_y</span> <span class="o">=</span> <span class="n">sand</span><span class="py">.y</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">highest_y</span> <span class="o">&gt;=</span> <span class="n">max_y</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Break if the source has been blocked.</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">sands</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SOURCE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">sands</span><span class="nf">.into_iter</span><span class="p">());</span>
    <span class="n">sorted</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">el1</span><span class="p">,</span> <span class="n">el2</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x_cmp</span> <span class="o">=</span> <span class="n">el1</span><span class="py">.x</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el2</span><span class="py">.x</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">x_cmp</span> <span class="o">==</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="p">{</span>
            <span class="n">el1</span><span class="py">.y</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el2</span><span class="py">.y</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">x_cmp</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"amount of sand is {:?}"</span><span class="p">,</span> <span class="n">sorted</span><span class="nf">.len</span><span class="p">());</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Run all by default or if a specific one was chosen. Useful for rendering just one.</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq,</span> <span class="nd">Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Rocks</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">dist</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">other</span><span class="py">.x</span> <span class="o">-</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="n">other</span><span class="py">.y</span> <span class="o">-</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">other</span><span class="py">.x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="py">.y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">other</span><span class="py">.y</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.x</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="py">.x</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.x</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="py">.x</span><span class="nf">.abs</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">other</span><span class="py">.x</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.y</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="py">.y</span><span class="nf">.clamp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.y</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="py">.y</span><span class="nf">.abs</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">down</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">left_down</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">right_down</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rocks</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="k">self</span><span class="py">.edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">edge_diff</span> <span class="o">=</span> <span class="n">right</span><span class="nf">.dist</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">point_diff</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.dist</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">edge_diff</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point_diff</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse point"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Rocks</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">maybe_edges</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nf">.split</span><span class="p">(</span><span class="s">" -&gt; "</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">maybe_edges</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">edge</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                <span class="n">has_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">has_err</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse as edges"</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">maybe_edges</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.unwrap</span><span class="p">())</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

            <span class="c1">// Check whether edges go diagonally.</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">in</span> <span class="n">edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">edge_diff</span> <span class="o">=</span> <span class="n">right</span><span class="nf">.dist</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="n">edge_diff</span><span class="py">.x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge_diff</span><span class="py">.y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"found an edge that isn't straight"</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">edges</span> <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_14">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute the command
<code>cargo run --release</code> to run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-15">Day 15: Beacon Exclusion Zone</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_13">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_14">Solution</h3>
<div class="paragraph">
<p>Part 1 was easy enough, I simply gave each exclusion zone a function that
provided all points within it at a certain y-coordinate, fed all of them into a
set, and then checked how many elements it had.
Not very pretty but worked well enough.</p>
</div>
<div class="paragraph">
<p>At first, I brute-forced part 2 and got lucky.
However, that solution wasn&#8217;t satisfying and then I found some more time to look
into this today.
Yeah!</p>
</div>
<div class="paragraph">
<p>The final solution to part 2 turned out to be one that I never expected to
perform well but that did, as it turns out.
What I do is I basically perform a line scan along the x axis for all y
coordinates.
For each y, I extract all non-empty overlaps between exclusion zones and the
scanning line and discarded those that were outside the playing field.
Then, I merged those overlaps.</p>
</div>
<div class="paragraph">
<p>To make merging overlaps, which are ranges, very easy, I sorted all of then
first by their x_min coordinate and, if those are equal, by their x_max
coordinate.
I never thought that sorting them would be efficient enough, but it is.
Once they have been sorted, merging them is easy.
If x_min of the first entry is not 0, we&#8217;ve found the coordinates.
Otherwise, we check whether x_min of the next range in line is greater than the
current x_max.
If so, we&#8217;ve found the empty spot.
If not, we increase our currently known x_max to the x_max of that range.
Once the known x_max reached 4,000,000, we know that this line doesn&#8217;t contain
the beacon.
Rinse repeat for every y until the distress beacon has been found.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">find_missing_x</span><span class="p">(</span>
    <span class="n">diamonds</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Diamond</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">outer_min</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">outer_max</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Extract all ranges at the given y-coordinate first.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ranges</span> <span class="o">=</span> <span class="n">diamonds</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.xrange_at_y</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="nf">.clamp</span><span class="p">(</span><span class="n">outer_min</span><span class="p">,</span> <span class="n">outer_max</span><span class="p">))</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">NULL_RANGE</span><span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// Then, we sort by left coordinate first and by right coordinate second. That makes finding</span>
    <span class="c1">// the missing x spot trivial.</span>
    <span class="n">ranges</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">range1</span><span class="p">,</span> <span class="n">range2</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left_cmp</span> <span class="o">=</span> <span class="n">range1</span><span class="py">.left</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range2</span><span class="py">.left</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">left_cmp</span> <span class="o">==</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="p">{</span>
            <span class="n">range1</span><span class="py">.right</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range2</span><span class="py">.right</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">left_cmp</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.left</span> <span class="o">!=</span> <span class="n">outer_min</span> <span class="p">{</span>
        <span class="c1">// Wouldn't that be nice.</span>
        <span class="nf">Some</span><span class="p">((</span><span class="n">outer_min</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">range</span> <span class="k">in</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// We can never find a left coordinate that is smaller than what we already have.</span>
            <span class="k">if</span> <span class="n">range</span><span class="py">.left</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
                <span class="c1">// Yeah, found it!</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="n">max</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">range</span><span class="py">.right</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">range</span><span class="py">.right</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">range</span><span class="py">.right</span> <span class="o">&lt;=</span> <span class="n">max</span> <span class="p">{</span>
                <span class="c1">// Don't do anything here.</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"there are no more conditions"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">):</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {} WITH Y {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">exclusion_zones</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Diamond</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"diamonds"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"number of diamons is {}"</span><span class="p">,</span> <span class="n">exclusion_zones</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">beacons</span> <span class="o">=</span> <span class="n">exclusion_zones</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="py">.bx</span><span class="p">,</span> <span class="n">el</span><span class="py">.by</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sensors</span> <span class="o">=</span> <span class="n">exclusion_zones</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="py">.x</span><span class="p">,</span> <span class="n">el</span><span class="py">.y</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">objects</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">beacons</span> <span class="p">|</span> <span class="o">&amp;</span><span class="n">sensors</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>
    <span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">exclusion_zones</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.xs_at_y</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">))</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="c1">// This is a lazy filter to detect clashes with existing objects but I didn't want to put</span>
        <span class="c1">// too much effort into part 1.</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">!</span><span class="n">objects</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.len</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"number of points along {} is {}"</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// There is guaranteed to be exactly one point.</span>
    <span class="k">let</span> <span class="n">missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">min</span><span class="o">..</span><span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.find_map</span><span class="p">(|</span><span class="n">y</span><span class="p">|</span> <span class="nf">find_missing_x</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exclusion_zones</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="o">=</span> <span class="n">missing</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"tuning frequency is {}"</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">max</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"there is no distress beacon"</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">2_000_000</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4_000_000</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq,</span> <span class="nd">Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Diamond</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">bx</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">by</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Range</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">left</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">right</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Range</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">clamp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">min</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">max</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Range</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.right</span> <span class="o">&lt;=</span> <span class="n">min</span> <span class="p">||</span> <span class="k">self</span><span class="py">.left</span> <span class="o">&gt;=</span> <span class="n">max</span> <span class="p">{</span>
            <span class="n">NULL_RANGE</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">Range</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">:</span> <span class="k">self</span><span class="py">.left</span><span class="nf">.clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">),</span>
                <span class="n">right</span><span class="p">:</span> <span class="k">self</span><span class="py">.right</span><span class="nf">.clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">NULL_RANGE</span><span class="p">:</span> <span class="n">Range</span> <span class="o">=</span> <span class="n">Range</span> <span class="p">{</span> <span class="n">left</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Diamond</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="s">"Sensor"</span><span class="p">,</span> <span class="s">"at"</span><span class="p">,</span> <span class="n">sensor_x</span><span class="p">,</span> <span class="n">sensor_y</span><span class="p">,</span> <span class="s">"closest"</span><span class="p">,</span> <span class="s">"beacon"</span><span class="p">,</span> <span class="s">"is"</span><span class="p">,</span> <span class="s">"at"</span><span class="p">,</span> <span class="n">beacon_x</span><span class="p">,</span> <span class="n">beacon_y</span><span class="p">]</span> <span class="k">=&gt;</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">sensor_x</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"x="</span><span class="p">)</span> <span class="p">||</span> <span class="o">!</span><span class="n">sensor_y</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"y="</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"malformed sensor coordinates"</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">beacon_x</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"x="</span><span class="p">)</span> <span class="p">||</span> <span class="o">!</span><span class="n">beacon_y</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"y="</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"malformed beacon coordinates"</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">conv</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">val</span><span class="nf">.trim_start_matches</span><span class="p">(</span><span class="s">"x="</span><span class="p">)</span>
                        <span class="nf">.trim_start_matches</span><span class="p">(</span><span class="s">"y="</span><span class="p">)</span>
                        <span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
                        <span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span>
                        <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">()</span>
                <span class="p">};</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">conv</span><span class="p">(</span><span class="n">sensor_x</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">conv</span><span class="p">(</span><span class="n">sensor_y</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">bx</span> <span class="o">=</span> <span class="nf">conv</span><span class="p">(</span><span class="n">beacon_x</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">by</span> <span class="o">=</span> <span class="nf">conv</span><span class="p">(</span><span class="n">beacon_y</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">bx</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">by</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="nf">.abs</span><span class="p">();</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">dist</span> <span class="p">})</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"negative distance encountered"</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse point"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Diamond</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">xs_at_y</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="n">Range</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span><span class="nf">.abs</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.dist</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">remaining</span> <span class="o">=</span> <span class="k">self</span><span class="py">.dist</span> <span class="o">-</span> <span class="n">dist</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="n">remaining</span><span class="o">..</span><span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">remaining</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="mi">0</span><span class="o">..</span><span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">xrange_at_y</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Range</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span><span class="nf">.abs</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.dist</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">remaining</span> <span class="o">=</span> <span class="k">self</span><span class="py">.dist</span> <span class="o">-</span> <span class="n">dist</span><span class="p">;</span>
            <span class="n">Range</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">,</span>
                <span class="n">right</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">remaining</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">NULL_RANGE</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_15">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute the command
<code>cargo run --release</code> to run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-16">Day 16: Proboscidea Volcanium</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_14">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_15">Solution</h3>
<div class="paragraph">
<p>Today&#8217;s part 2 was pretty tricky and I guess rust&#8217;s efficiency kind of saved me.
I actually assumed something completely different, but luckily I refrained from
overcomplicating part 1 because of that.</p>
</div>
<div class="paragraph">
<p>Part 1 was a straightforward backtracking problem.
A stupid mistake caused me to lose quite some time, though, which meant I had a
lot less time for part 2.
The main idea I had was not to simulate the passing of time but instead have
each valve contribute directly to the overall release value because we know for
how long it will be opened.
Furthermore, I computed pairwise distances before running any backtracking and
ignored all those valves that had a zero release rate.
Pairwise distances can be computed easily by bubbling a nearest neighbour sphere
outwards.</p>
</div>
<div class="paragraph">
<p>I still solved part 2 like a backtracking problem.
The added complexity comes from the fact that the elephant can also act.</p>
</div>
<div class="paragraph">
<p>I modelled the world in a way that had the human act first on a specific number
of valves.
Then time is reset, and the elephant acts on as many valves at it likes from
among those valves that the human hasn&#8217;t acted on, yet, until there are no more
valves left or time runs out.
I then decrease the number of valves the human acts on in steps of 1 starting at
the maximum possible number and take the overall highest release value.</p>
</div>
<div class="paragraph">
<p>I added a quick stopping condition, which worked for my inputs but might not
translate.
Set the env var <code>QUICK=0</code> to disable quick mode, which is enabled by default.
Quick mode assumes that, as the number of valves opened by the human decreases,
the best possible release value will only ever increase.
With quick mode enabled, this runs in &lt;20s on my &gt;10year old business notebook.
Without quick mode, it takes &lt;3min.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="c1">// We map each set of two chars to one usize. Since there are 26 letters in the alphabet, we map</span>
<span class="c1">// each pair to 100*ord(first) + ord(second) where ord("A")==0 and ord("Z")==25. Thus, "AA" maps to</span>
<span class="c1">// zero.</span>
<span class="k">const</span> <span class="n">START</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">pairwise_distances</span><span class="p">(</span><span class="n">valve_map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Valve</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">valve</span><span class="p">)</span> <span class="k">in</span> <span class="n">valve_map</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">curr_dist</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="c1">// All neighbours have a distance of one.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">valve</span>
            <span class="py">.neighbours</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">curr_dist</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="c1">// We always remeber new points we added. Those points have a distance of one more than the</span>
        <span class="c1">// previous max.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_valves</span> <span class="o">=</span> <span class="n">distances</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="c1">// We include the point itself for ease of use later on.</span>
        <span class="n">distances</span><span class="nf">.insert</span><span class="p">(</span><span class="n">name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// Repeat until no more neighbours have been added.</span>
        <span class="k">while</span> <span class="n">new_valves</span><span class="nf">.len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">curr_dist</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="c1">// Determine those valve names that are at the next distance.</span>
            <span class="n">new_valves</span> <span class="o">=</span> <span class="n">new_valves</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="c1">// Extract the actual valve data.</span>
                <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">valve_map</span><span class="nf">.get</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                <span class="c1">// Get all neighbours of those valves we just extracted in one big iterator.</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.neighbours</span><span class="nf">.iter</span><span class="p">())</span>
                <span class="nf">.flatten</span><span class="p">()</span>
                <span class="c1">// Get a unique set of the names of those valves that may have been added in this</span>
                <span class="c1">// iteration.</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="c1">// Keep only those to which we haven't yet computed distances.</span>
                <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">distances</span><span class="nf">.get</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nb">None</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="nf">.clone</span><span class="p">())</span>
                    <span class="p">}</span>
                <span class="p">})</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="c1">// Add those distances.</span>
            <span class="n">distances</span><span class="nf">.extend</span><span class="p">(</span><span class="n">new_valves</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">curr_dist</span><span class="p">)));</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="nf">.extend</span><span class="p">(</span>
            <span class="n">distances</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">new_valve</span><span class="p">,</span> <span class="n">dist</span><span class="p">)|</span> <span class="p">((</span><span class="n">name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">new_valve</span><span class="p">),</span> <span class="n">dist</span><span class="p">)),</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">result</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">backtrack</span><span class="p">(</span>
    <span class="n">valve_name_map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Valve</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">distances</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">relevant_valves</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">current_spot</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="p">,</span>
    <span class="n">current_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">max_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">current_best</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">visited</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">allow_elephant</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">elephant_depth</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Check that None is the first entry in the list of relevant_valves.</span>
    <span class="k">if</span> <span class="n">allow_elephant</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">relevant_valves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"the first relevant valve has to be None"</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">next_best</span> <span class="o">=</span> <span class="n">current_best</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">maybe_next_spot</span> <span class="k">in</span> <span class="n">relevant_valves</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">possible_best</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next_spot</span><span class="p">)</span> <span class="o">=</span> <span class="n">maybe_next_spot</span> <span class="p">{</span>
            <span class="c1">// Let the human do their thing.</span>
            <span class="c1">// Skip spots we've already seen.</span>
            <span class="k">if</span> <span class="n">visited</span><span class="nf">.contains</span><span class="p">(</span><span class="n">next_spot</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">time_spent_traveling</span> <span class="o">=</span> <span class="n">distances</span>
                <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">current_spot</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">next_spot</span><span class="nf">.clone</span><span class="p">()))</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot retrieve distance"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

            <span class="c1">// We add 1 because of the time it takes to open the valve.</span>
            <span class="k">let</span> <span class="n">time_of_next_valve_opening</span> <span class="o">=</span> <span class="n">current_time</span> <span class="o">+</span> <span class="n">time_spent_traveling</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="c1">// Check whether we have any time left to open another valve.</span>
            <span class="k">if</span> <span class="n">time_of_next_valve_opening</span> <span class="o">&gt;=</span> <span class="n">max_time</span> <span class="p">{</span>
                <span class="c1">// If not, we found the best we can using this route. Skip this spot.</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// We will be able to open that valve.</span>
                <span class="c1">// Remember that we visited it.</span>
                <span class="n">visited</span><span class="nf">.insert</span><span class="p">(</span><span class="n">next_spot</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="c1">// Check by how much the next valve can increase our release value.</span>
                <span class="k">let</span> <span class="n">next_valve_rate</span> <span class="o">=</span> <span class="n">valve_name_map</span>
                    <span class="nf">.get</span><span class="p">(</span><span class="n">next_spot</span><span class="p">)</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot retrieve valve"</span><span class="p">))</span><span class="o">?</span>
                    <span class="py">.rate</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">benefit</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_time</span> <span class="o">-</span> <span class="n">time_of_next_valve_opening</span><span class="p">)</span> <span class="o">*</span> <span class="n">next_valve_rate</span><span class="p">;</span>

                <span class="nf">backtrack</span><span class="p">(</span>
                    <span class="n">valve_name_map</span><span class="p">,</span>
                    <span class="n">distances</span><span class="p">,</span>
                    <span class="n">relevant_valves</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">next_spot</span><span class="p">,</span>
                    <span class="n">time_of_next_valve_opening</span><span class="p">,</span>
                    <span class="n">max_time</span><span class="p">,</span>
                    <span class="n">current_best</span> <span class="o">+</span> <span class="n">benefit</span><span class="p">,</span>
                    <span class="n">visited</span><span class="p">,</span>
                    <span class="n">allow_elephant</span><span class="p">,</span>
                    <span class="n">elephant_depth</span><span class="p">,</span>
                <span class="p">)</span><span class="o">?</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">allow_elephant</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">elephant_depth</span> <span class="p">{</span>
            <span class="c1">// Let the elephant also do its thing, allowing it only to visit those points that we</span>
            <span class="c1">// haven't yet visited. Actually, this has to be the first step we do for the algorithm</span>
            <span class="c1">// to work. Otherwise, better paths will be missed.</span>
            <span class="nf">backtrack</span><span class="p">(</span>
                <span class="n">valve_name_map</span><span class="p">,</span>
                <span class="n">distances</span><span class="p">,</span>
                <span class="n">relevant_valves</span><span class="p">,</span>
                <span class="c1">// The elephant starts at the start.</span>
                <span class="o">&amp;</span><span class="n">START</span><span class="p">,</span>
                <span class="c1">// Time is reset.</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">max_time</span><span class="p">,</span>
                <span class="c1">// We will still have acted, meaning the elephant can only ever increase the</span>
                <span class="c1">// release value.</span>
                <span class="n">next_best</span><span class="p">,</span>
                <span class="c1">// The elephant may only visit those valves that we haven't yet visited.</span>
                <span class="n">visited</span><span class="p">,</span>
                <span class="c1">// Don't allow yet another elephant to explore.</span>
                <span class="k">false</span><span class="p">,</span>
                <span class="n">elephant_depth</span><span class="p">,</span>
            <span class="p">)</span><span class="o">?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// This block allows us to still run part 1 despite all the code related to elephants.</span>
            <span class="mi">0</span>
        <span class="p">};</span>
        <span class="k">if</span> <span class="n">possible_best</span> <span class="o">&gt;</span> <span class="n">next_best</span> <span class="p">{</span>
            <span class="n">next_best</span> <span class="o">=</span> <span class="n">possible_best</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Forget that we visited the point but only if this isn't the elephant's turn.</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next_spot</span><span class="p">)</span> <span class="o">=</span> <span class="n">maybe_next_spot</span> <span class="p">{</span>
            <span class="n">visited</span><span class="nf">.remove</span><span class="p">(</span><span class="n">next_spot</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Return the bext one we found.</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">next_best</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">valves</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Valve</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"valves"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// We only want to look at valves that have non-zero rates for part 1. I suspect it's gonna be</span>
    <span class="c1">// different for part 2. Nope, it's not.</span>
    <span class="k">let</span> <span class="n">relevant_valves</span> <span class="o">=</span> <span class="n">valves</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">el</span><span class="py">.rate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="py">.name</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// Compute pairwise distances.</span>
    <span class="k">let</span> <span class="n">valve_name_map</span> <span class="o">=</span> <span class="n">valves</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="py">.name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">el</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">distances</span> <span class="o">=</span> <span class="nf">pairwise_distances</span><span class="p">(</span><span class="o">&amp;</span><span class="n">valve_name_map</span><span class="p">);</span>

    <span class="c1">// Backtrack the solution.</span>
    <span class="k">let</span> <span class="n">start_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_time</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">start_release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">visited</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">relevant_valves</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">max_part1</span> <span class="o">=</span> <span class="nf">backtrack</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">valve_name_map</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">distances</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">relevant_valves</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">START</span><span class="p">,</span>
        <span class="n">start_time</span><span class="p">,</span>
        <span class="n">max_time</span><span class="p">,</span>
        <span class="n">start_release</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="n">visited</span><span class="p">,</span>
        <span class="k">false</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"part 1: {}"</span><span class="p">,</span> <span class="n">max_part1</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// Backtrack the solution.</span>

    <span class="k">let</span> <span class="n">max_time_part2</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="c1">// A value of None means that the human should stop what they are doing and let the elephant do</span>
    <span class="c1">// its thing. It has to be the first entry in relevant_valves. Otherwise, better paths are</span>
    <span class="c1">// lost, somehow.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">relevant_with_elephant</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">];</span>
    <span class="n">relevant_with_elephant</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">relevant_valves</span><span class="p">);</span>

    <span class="c1">// Quick mode uses the below assumptions and we use it by default.</span>
    <span class="k">let</span> <span class="n">quick_mode</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="s">"QUICK"</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="s">"1"</span><span class="nf">.to_string</span><span class="p">())</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// This is a bit hacky but it works. We check what happens if the human is guaranteed a certain</span>
    <span class="c1">// number of valves because the elephant can only open those that the human didn't approach.</span>
    <span class="c1">// Then, we assume that, the fewer valves the human opens, the higher the overal pressure</span>
    <span class="c1">// release gets because the elephant can open some. At some point, since this is at least a</span>
    <span class="c1">// certain number of steps, there will no longer be an increase followed by a decrease, which</span>
    <span class="c1">// is our stopping point. This is an assumption, which tunrs out to hold, but it might not for</span>
    <span class="c1">// all possible inputs. If it doesn't simply disable quick mode.</span>
    <span class="k">for</span> <span class="n">num_human_valves</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">relevant_valves</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Reset some mutable data structures.</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">relevant_valves</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="nf">backtrack</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">valve_name_map</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">distances</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">relevant_with_elephant</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">START</span><span class="p">,</span>
            <span class="n">start_time</span><span class="p">,</span>
            <span class="n">max_time_part2</span><span class="p">,</span>
            <span class="n">start_release</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="n">visited</span><span class="p">,</span>
            <span class="k">true</span><span class="p">,</span>
            <span class="n">num_human_valves</span><span class="p">,</span>
        <span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"part 2: with {} guaranteed human valves: {}"</span><span class="p">,</span>
            <span class="n">num_human_valves</span><span class="p">,</span> <span class="n">max</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="n">quick_mode</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">best</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">max</span> <span class="o">&gt;</span> <span class="n">best</span> <span class="p">{</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"part 2: {}"</span><span class="p">,</span> <span class="n">best</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Valve</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">name</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">rate</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">neighbours</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Using u8 instead of two-character strings speeds the entire thing up by about a factor of 4. If</span>
<span class="c1">// you have other character combinations, simply add them here.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">str_to_usize</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
        <span class="s">"AA"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="s">"AF"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="s">"AK"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="s">"BB"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
        <span class="s">"BC"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="s">"BF"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="s">"BV"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
        <span class="s">"CA"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
        <span class="s">"CC"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
        <span class="s">"CM"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
        <span class="s">"DD"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
        <span class="s">"DO"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
        <span class="s">"DW"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
        <span class="s">"EE"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span>
        <span class="s">"EI"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span>
        <span class="s">"EJ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span>
        <span class="s">"EV"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
        <span class="s">"FD"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span>
        <span class="s">"FF"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span>
        <span class="s">"FN"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">19</span><span class="p">),</span>
        <span class="s">"GG"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
        <span class="s">"GO"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span>
        <span class="s">"GW"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span>
        <span class="s">"HH"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span>
        <span class="s">"HO"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span>
        <span class="s">"HP"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
        <span class="s">"HR"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">26</span><span class="p">),</span>
        <span class="s">"HX"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">27</span><span class="p">),</span>
        <span class="s">"II"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span>
        <span class="s">"IR"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">29</span><span class="p">),</span>
        <span class="s">"JJ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
        <span class="s">"JQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">31</span><span class="p">),</span>
        <span class="s">"JS"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
        <span class="s">"KH"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">33</span><span class="p">),</span>
        <span class="s">"KL"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">34</span><span class="p">),</span>
        <span class="s">"KQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">35</span><span class="p">),</span>
        <span class="s">"KX"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">36</span><span class="p">),</span>
        <span class="s">"LR"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">37</span><span class="p">),</span>
        <span class="s">"MS"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">38</span><span class="p">),</span>
        <span class="s">"MW"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">39</span><span class="p">),</span>
        <span class="s">"NB"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">40</span><span class="p">),</span>
        <span class="s">"NC"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">41</span><span class="p">),</span>
        <span class="s">"NQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span>
        <span class="s">"OF"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">43</span><span class="p">),</span>
        <span class="s">"OM"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">44</span><span class="p">),</span>
        <span class="s">"OQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">45</span><span class="p">),</span>
        <span class="s">"OX"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">46</span><span class="p">),</span>
        <span class="s">"PC"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">47</span><span class="p">),</span>
        <span class="s">"PD"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">48</span><span class="p">),</span>
        <span class="s">"PH"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">49</span><span class="p">),</span>
        <span class="s">"PU"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
        <span class="s">"QE"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">51</span><span class="p">),</span>
        <span class="s">"RX"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">52</span><span class="p">),</span>
        <span class="s">"RZ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">53</span><span class="p">),</span>
        <span class="s">"SG"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">54</span><span class="p">),</span>
        <span class="s">"SM"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">55</span><span class="p">),</span>
        <span class="s">"SY"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">56</span><span class="p">),</span>
        <span class="s">"TN"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">57</span><span class="p">),</span>
        <span class="s">"TS"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">58</span><span class="p">),</span>
        <span class="s">"TY"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">59</span><span class="p">),</span>
        <span class="s">"UE"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span>
        <span class="s">"VL"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">61</span><span class="p">),</span>
        <span class="s">"WE"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">62</span><span class="p">),</span>
        <span class="s">"WU"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">63</span><span class="p">),</span>
        <span class="s">"WW"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="s">"XG"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">65</span><span class="p">),</span>
        <span class="s">"XN"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">66</span><span class="p">),</span>
        <span class="s">"YD"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">67</span><span class="p">),</span>
        <span class="s">"YQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">68</span><span class="p">),</span>
        <span class="s">"ZQ"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">69</span><span class="p">),</span>
        <span class="s">"ZX"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">70</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Valve</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rate</span><span class="p">:</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">neighbours</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">s</span><span class="nf">.split</span><span class="p">(</span><span class="s">";"</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">valve_data</span><span class="p">,</span> <span class="n">tunnel_data</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">valve_data</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
                    <span class="p">[</span><span class="s">"Valve"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s">"has"</span><span class="p">,</span> <span class="s">"flow"</span><span class="p">,</span> <span class="n">rate_str</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">name</span> <span class="o">=</span>
                            <span class="nf">str_to_usize</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot convert chars to usize"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
                        <span class="n">rate</span> <span class="o">=</span> <span class="n">rate_str</span><span class="nf">.trim_start_matches</span><span class="p">(</span><span class="s">"rate="</span><span class="p">)</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse valve data"</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">tunnel_data</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">" tunnels lead to valve"</span><span class="p">)</span>
                    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tunnel_data</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">" tunnel leads to valve"</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse tunnel data"</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">maybe_neighbours</span> <span class="o">=</span> <span class="n">tunnel_data</span>
                    <span class="nf">.split_whitespace</span><span class="p">()</span>
                    <span class="nf">.skip</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">str_to_usize</span><span class="p">(</span><span class="n">el</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">","</span><span class="p">)))</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
                <span class="c1">// We let this panic if it wants to.</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="n">maybe_neighbours</span>
                    <span class="nf">.into_iter</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.unwrap</span><span class="p">())</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">rate</span><span class="p">,</span>
                    <span class="n">neighbours</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse valve"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_16">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-17">Day 17: Pyroclastic Flow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_15">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_16">Solution</h3>
<div class="paragraph">
<p>Part 1 was a straightforward implementation of a tetris-like game.
I used a <code>HashMap</code> of 2d vectors to represent spots that were occupied by rocks.
If you read the rules carefully and don&#8217;t make a mistake with the shape of the
rocks, you&#8217;re good.</p>
</div>
<div class="paragraph">
<p>Part 2 was very tricky for me and I fell into so many traps that I almost gave
up.
It was clear from the start that you can&#8217;t simply keep expanding the playing
field until the 1 billionth rock had dropped.
Instead, there had to be some repetition involved.
Finding the correct point from which to extrapolate into the future was the crux
here.
It basically took an entire day of background thinking and trying it out every
now and again to solve.</p>
</div>
<div class="paragraph">
<p>There are two infinite streams that need to repeat, the stream of rocks and the
stream of air.
For the example, the lengths of both are nicely divisible.
not so much for the real puzzle.
Instead, I check the ground each square rock has settled on after it settled as
well as the position in the infinite air stream at that time.
If the shape of the ground, the type of rock, and the position in the air stream
have the same values again, we found our repetition.
Ground extraction is explained in the code and works reasonably well.
I even neglect some grounds that would be tricky to work with, which is maybe
not even needed.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">Cycle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">render</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">rock</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rock</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">field</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">min_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">rock_fields</span> <span class="o">=</span> <span class="n">rock</span><span class="nf">.occupied_fields</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="p">(</span><span class="n">min_y</span><span class="o">..</span><span class="n">max_y</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">min_x</span><span class="o">..=</span><span class="n">max_x</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Pos</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">};</span>
            <span class="k">if</span> <span class="n">field</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rock_fields</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// This a conflict field.</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"X"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">field</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"#"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">rock_fields</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"|"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">print!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">is_blocked</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">data</span><span class="p">::</span><span class="n">Blocked</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">check</span><span class="py">.x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">check</span><span class="py">.x</span> <span class="o">&gt;=</span> <span class="n">width</span> <span class="p">{</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="n">Wall</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">field</span><span class="nf">.contains</span><span class="p">(</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="n">Rock</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">check</span><span class="py">.y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// This is hacky but we simulate a floor of rocks so that a downward operation will have</span>
        <span class="c1">// the rock to settle on.</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="n">Rock</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Nice means no rock can muddle its way through. There is a direct connection from the left wall</span>
<span class="c1">// to the right wall.</span>
<span class="k">fn</span> <span class="nf">is_nice_ground</span><span class="p">(</span><span class="n">ground</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">candidates</span> <span class="o">=</span> <span class="n">ground</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">if</span> <span class="n">el</span><span class="py">.x</span> <span class="o">==</span> <span class="n">x</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">candidates</span> <span class="o">&amp;</span> <span class="n">field</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">candidates</span><span class="nf">.len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidates</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.right_env</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">candidates</span> <span class="o">&amp;</span> <span class="n">field</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">x</span> <span class="o">==</span> <span class="mi">8</span>
<span class="p">}</span>

<span class="c1">// We try to find the ground the last rock settled on. We basically go from top to the bottom until</span>
<span class="c1">// we have found at least one rock at each of the possible 7 x positions. For piece of mind, we</span>
<span class="c1">// only consider nice grounds (see is_nice_ground for a definition).</span>
<span class="k">fn</span> <span class="nf">get_ground</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">top_rock</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">found</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="mi">7</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bottom</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">top_rock</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">top_rock</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">7</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">check</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Pos</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">};</span>
            <span class="k">if</span> <span class="n">field</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">found</span><span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="n">bottom</span><span class="nf">.insert</span><span class="p">(</span><span class="n">check</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">found</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">*</span><span class="n">el</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">is_nice_ground</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bottom</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">disp</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Pos</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="n">min_y</span> <span class="p">};</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">bottom</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">))</span><span class="nf">.collect</span><span class="p">())</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Rep stands for repetition.</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rep</span> <span class="p">{</span>
    <span class="n">round</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">top_rock</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">ground</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Yeah, we are playing tetris today.</span>
<span class="c1">// This function looked OK until after part 1 but now it's horrible, but I don't want to take any</span>
<span class="c1">// time to refactor.</span>
<span class="k">fn</span> <span class="nf">play_tetris</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">stream</span><span class="p">:</span> <span class="n">Cycle</span><span class="o">&lt;</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Push</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">rocks</span><span class="p">:</span> <span class="n">Cycle</span><span class="o">&lt;</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">max_num_rocks</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">num_steam_steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">num_rock_steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="c1">// trigger for part 2.</span>
    <span class="n">do_repeat</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">possible_rep_store</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Rep</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// We will track the positions of all rocks with this.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">field</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// At the beginning, there is no rock yet. Thus, the top position is the floor.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top_rock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Round counts rocks.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">round</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Step counts gusts of air.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="n">round</span> <span class="o">&lt;</span> <span class="n">max_num_rocks</span> <span class="p">{</span>
        <span class="n">round</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rock</span> <span class="o">=</span> <span class="n">rocks</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"weren't there infinitely many rocks"</span><span class="p">);</span>
        <span class="c1">// Spwan a rock.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pos</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Pos</span> <span class="p">{</span>
            <span class="c1">// There also have to be 2 free spaces in x direction. Thus, it spawns at x</span>
            <span class="c1">// coordinate 3.</span>
            <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="c1">// There have to be 3 free spaces in y direction. Thus, it spwans 4 units</span>
            <span class="c1">// further above.</span>
            <span class="n">y</span><span class="p">:</span> <span class="n">top_rock</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_settled</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">has_settled</span> <span class="p">{</span>
            <span class="c1">// Get the next stream element. This is an infinite iterator.</span>
            <span class="k">let</span> <span class="n">push</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"wasn't this supposed to be infinite"</span><span class="p">);</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="c1">// Apply the movement operation to the side.</span>
            <span class="k">let</span> <span class="n">next_pushed</span> <span class="o">=</span> <span class="n">push</span><span class="nf">.apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
            <span class="c1">// Check whether there is any collision.</span>
            <span class="k">let</span> <span class="n">push_blocked_check</span> <span class="o">=</span> <span class="n">rock</span>
                <span class="nf">.occupied_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_pushed</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">el</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
                <span class="nf">.find</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="nb">None</span><span class="p">);</span>
            <span class="c1">// Accept the movement only if we haven't been blocked.</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nb">None</span> <span class="o">=</span> <span class="n">push_blocked_check</span> <span class="p">{</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">next_pushed</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Move downwards and check again.</span>
            <span class="k">let</span> <span class="n">next_dropped</span> <span class="o">=</span> <span class="n">pos</span><span class="nf">.drop</span><span class="p">();</span>
            <span class="c1">// Check whether there is any collision.</span>
            <span class="k">let</span> <span class="n">drop_blocked_check</span> <span class="o">=</span> <span class="n">rock</span>
                <span class="nf">.occupied_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_dropped</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="nf">is_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">el</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
                <span class="nf">.find</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Blocked</span><span class="p">::</span><span class="n">Rock</span><span class="p">);</span>
            <span class="c1">// Accept the movement only if we haven't been blocked.</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">drop_blocked_check</span> <span class="p">{</span>
                <span class="c1">// The rock has settled!</span>
                <span class="n">has_settled</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="c1">// Find the topmost position and occupy all fields of the rock.</span>
                <span class="n">field</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rock</span><span class="nf">.occupied_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">));</span>
                <span class="c1">// Check whether the rock that just settled reaches higher than before.</span>
                <span class="k">let</span> <span class="n">possible_top_rock</span> <span class="o">=</span> <span class="n">rock</span>
                    <span class="nf">.occupied_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
                    <span class="nf">.max</span><span class="p">()</span>
                    <span class="nf">.expect</span><span class="p">(</span><span class="s">"cannot find top rock"</span><span class="p">);</span>
                <span class="k">if</span> <span class="n">possible_top_rock</span> <span class="o">&gt;</span> <span class="n">top_rock</span> <span class="p">{</span>
                    <span class="n">top_rock</span> <span class="o">=</span> <span class="n">possible_top_rock</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// The rock hasn't settled yet. Accept the update.</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">next_dropped</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// This entire block is horrible and takes care of part 2. Ignore it for part 1.</span>
        <span class="k">if</span> <span class="n">do_repeat</span> <span class="o">&amp;&amp;</span> <span class="n">round</span> <span class="o">%</span> <span class="n">num_rock_steps</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// If we're in here, a square block has settled.</span>
            <span class="c1">// Determine our position in the repeating rock and steam streams.</span>
            <span class="k">let</span> <span class="n">rep_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">round</span> <span class="o">%</span> <span class="n">num_rock_steps</span><span class="p">,</span> <span class="n">step</span> <span class="o">%</span> <span class="n">num_steam_steps</span><span class="p">);</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ground</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_ground</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">top_rock</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// If we're in here, then the rock has settled on a patch of ground that is nice</span>
                <span class="c1">// (i.e. where no rock can muddle its way through).</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">possible_rep</span><span class="p">)</span> <span class="o">=</span> <span class="n">possible_rep_store</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rep_key</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// If we're in here, we have already found this type of rock settling at this</span>
                    <span class="c1">// position in the stream/gust of air sequence.</span>
                    <span class="c1">// Check whether the ground repeated, too.</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="o">=</span> <span class="n">possible_rep</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.find_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">el</span><span class="py">.ground</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">ground</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="py">.ground</span> <span class="o">^</span> <span class="o">&amp;</span><span class="n">ground</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nb">None</span>
                        <span class="p">}</span>
                    <span class="p">})</span> <span class="p">{</span>
                        <span class="c1">// If we're in here, we found the same type of rock that settled at the</span>
                        <span class="c1">// same position in the steam stream AND that rock settled on an identical</span>
                        <span class="c1">// patch of ground as a previous rock. That means everything will repeat</span>
                        <span class="c1">// from here on out.</span>
                        <span class="c1">//</span>
                        <span class="c1">// Clear the field to save memory. Then, fast forward time and use the most</span>
                        <span class="c1">// recently found ground to reinitialise the field.</span>
                        <span class="n">field</span><span class="nf">.clear</span><span class="p">();</span>
                        <span class="k">let</span> <span class="n">rounds_in_loop</span> <span class="o">=</span> <span class="n">round</span> <span class="o">-</span> <span class="n">rep</span><span class="py">.round</span><span class="p">;</span>
                        <span class="k">let</span> <span class="n">increase_per_loop</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_rock</span> <span class="o">-</span> <span class="n">rep</span><span class="py">.top_rock</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
                        <span class="k">let</span> <span class="n">loops_remaining</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_num_rocks</span> <span class="o">-</span> <span class="n">round</span><span class="p">)</span> <span class="o">/</span> <span class="n">rounds_in_loop</span><span class="p">;</span>
                        <span class="n">round</span> <span class="o">+=</span> <span class="n">loops_remaining</span> <span class="o">*</span> <span class="n">rounds_in_loop</span><span class="p">;</span>
                        <span class="n">top_rock</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loops_remaining</span> <span class="o">*</span> <span class="n">increase_per_loop</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
                        <span class="c1">// Displace the ground to where it belongs. It will not form the top of the</span>
                        <span class="c1">// field. Because the ground is nice, no rock can fall through it.</span>
                        <span class="k">let</span> <span class="n">top_rock_in_ground</span> <span class="o">=</span> <span class="n">ground</span>
                            <span class="nf">.iter</span><span class="p">()</span>
                            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
                            <span class="nf">.max</span><span class="p">()</span>
                            <span class="nf">.expect</span><span class="p">(</span><span class="s">"there is no ground"</span><span class="p">);</span>
                        <span class="k">let</span> <span class="n">disp</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Pos</span> <span class="p">{</span>
                            <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">y</span><span class="p">:</span> <span class="n">top_rock</span> <span class="o">-</span> <span class="n">top_rock_in_ground</span><span class="p">,</span>
                        <span class="p">};</span>
                        <span class="n">field</span> <span class="o">=</span> <span class="n">ground</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Remember this ground.</span>
                        <span class="n">possible_rep</span><span class="nf">.push</span><span class="p">(</span><span class="n">Rep</span> <span class="p">{</span>
                            <span class="n">round</span><span class="p">,</span>
                            <span class="n">top_rock</span><span class="p">,</span>
                            <span class="n">ground</span><span class="p">,</span>
                        <span class="p">});</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// Remember the ground for this combination of rock and position in the steam</span>
                    <span class="c1">// stream.</span>
                    <span class="k">let</span> <span class="n">rep_val</span> <span class="o">=</span> <span class="n">Rep</span> <span class="p">{</span>
                        <span class="n">round</span><span class="p">,</span>
                        <span class="n">top_rock</span><span class="p">,</span>
                        <span class="n">ground</span><span class="p">,</span>
                    <span class="p">};</span>
                    <span class="n">possible_rep_store</span><span class="nf">.insert</span><span class="p">(</span><span class="n">rep_key</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">rep_val</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">top_rock</span> <span class="k">as</span> <span class="nb">usize</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">max_num_rocks</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Stream</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"stream"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.nth</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"found no stream"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">num_pushes</span> <span class="o">=</span> <span class="n">stream</span><span class="py">.flow</span><span class="nf">.len</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"push sequence has {} elements"</span><span class="p">,</span> <span class="n">num_pushes</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">num_rocks</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">variant_count</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Rock</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"rock sequence has {} elements"</span><span class="p">,</span> <span class="n">num_rocks</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">tallness</span> <span class="o">=</span> <span class="nf">play_tetris</span><span class="p">(</span>
        <span class="n">stream</span><span class="nf">.infinite</span><span class="p">(),</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">Rock</span><span class="p">::</span><span class="nf">infinite_stream</span><span class="p">(),</span>
        <span class="n">max_num_rocks</span><span class="p">,</span>
        <span class="n">num_pushes</span><span class="p">,</span>
        <span class="n">num_rocks</span><span class="p">,</span>
        <span class="c1">// Works but hacky trigger for part 2 ^^.</span>
        <span class="n">max_num_rocks</span> <span class="o">&gt;</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"tower will be {} tall after {} rocks"</span><span class="p">,</span>
        <span class="n">tallness</span><span class="p">,</span> <span class="n">max_num_rocks</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">2022</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">2022</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">1_000_000_000_000</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">1_000_000_000_000</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Push</span> <span class="p">{</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pos</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Stream</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Push</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// The position of each rock is indicated by the point in its bottom left. There doesn't have to be</span>
<span class="c1">// anything there?</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Rock</span> <span class="p">{</span>
    <span class="n">Minus</span><span class="p">,</span>
    <span class="n">Plus</span><span class="p">,</span>
    <span class="n">InverseL</span><span class="p">,</span>
    <span class="n">I</span><span class="p">,</span>
    <span class="n">Block</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Blocked</span> <span class="p">{</span>
    <span class="n">Rock</span><span class="p">,</span>
    <span class="n">Wall</span><span class="p">,</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Pos</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">right_env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Push</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Pos</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Pos</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Left</span> <span class="k">=&gt;</span> <span class="n">Pos</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Right</span> <span class="k">=&gt;</span> <span class="n">Pos</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rock</span> <span class="p">{</span>
    <span class="c1">// Get an infinite stream of rocks in the correct order.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">infinite_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">Cycle</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">Rock</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Minus</span><span class="p">,</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Plus</span><span class="p">,</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">InverseL</span><span class="p">,</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">I</span><span class="p">,</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Block</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.cycle</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// We order the returned positions in such a way that we have the highest likelihood of getting</span>
    <span class="c1">// a collision early on.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">occupied_fields</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Pos</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Minus</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">],</span>
            <span class="c1">// This one has no rock at 0,0!</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Plus</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">],</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Block</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">],</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">I</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">],</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">InverseL</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">Pos</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="py">.y</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">],</span>
        <span class="p">}</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Stream</span> <span class="p">{</span>
    <span class="c1">// This consumes the stream object, but we don't need it anymore.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">infinite</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">Cycle</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">Push</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.flow</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Stream</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
            <span class="n">flow</span><span class="p">:</span> <span class="n">s</span>
                <span class="nf">.chars</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
                    <span class="sc">'&gt;'</span> <span class="k">=&gt;</span> <span class="nn">Push</span><span class="p">::</span><span class="n">Right</span><span class="p">,</span>
                    <span class="sc">'&lt;'</span> <span class="k">=&gt;</span> <span class="nn">Push</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"oh no, we got weird input"</span><span class="p">),</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_17">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-18">Day 18: Boiling Boulders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_16">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_17">Solution</h3>
<div class="paragraph">
<p>Today was easy, yeah!
For part 1, simply put all lava points in a set.
Then, for each lava point, check for each neighbour whether that one is a lava
point itself.
If not, count it.</p>
</div>
<div class="paragraph">
<p>Part 2 was a bit more tricky and I lost some time due to an overflow that I
didn&#8217;t notice at first.
(Note to self: Always run in development mode first and only switch to release
mode if the speed up is needed because release mode will silently ignore
overflows.)</p>
</div>
<div class="paragraph">
<p>I was wondering how to detect air pockets.
My idea was to repurpose the <code>A*</code> algorithm developed for day 12.
I first extended it to 3 dimensions, which was straightforward.
Then, I found the smallest cuboid that contains all lava.
Then, I had <code>A*</code> search a path from each block in that cuboid to a block in a
top corner.
To ensure that I would always be able to find a path from any block that is
conncted to the outside, I added one layer of air to each of the 6 sides of the
cuboid.
Whenever I could not find a path, all blocks that the algorithm looked at are
known to be part of air pockets.
Whenever a path could be found, all blocks that the algorithm looked at are
known to not be air pockets.
That helps reduce the number of blocks to look at.</p>
</div>
<div class="paragraph">
<p>In the end, I fill all air pockets with fake lava and apply the same algorithm
from part 1 again.
I guess a breadth first search would have been more applicable, but I already
had a working pathfinding algorithm, so I repurposed it.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="n">find_path</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">estimator_fn</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ref_point</span> <span class="o">=</span> <span class="n">end</span><span class="nf">.pos</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">|</span> <span class="nf">estimator_fn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref_point</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">get_node</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">graph</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="nf">.as_node</span><span class="p">())</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"node not found"</span><span class="p">))</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">checkable</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Add starting point to resulting path.</span>
    <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// Add neighbours of starting point to list of checkable values. Ignore neighbouring points</span>
    <span class="c1">// that are not part of the graph.</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">start</span><span class="nf">.neighbours</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// Estimated costs are the most direct possible connection plus 1, since every step costs</span>
        <span class="c1">// one.</span>
        <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="nf">.pos</span><span class="p">(),</span> <span class="nf">estimator</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)));</span>
        <span class="c1">// connections.insert(neigh_node, (Some(start.pos()), 1));</span>
    <span class="p">}</span>

    <span class="c1">// Search until we added the final node to the path or until there is nothing more to check.</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">checkable</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// Get node with minimum _estimated_ cost.</span>
        <span class="k">let</span> <span class="n">next_best_node</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.iter_mut</span><span class="p">()</span>
            <span class="c1">// Get node with minimum estimated cost.</span>
            <span class="nf">.min_by</span><span class="p">(|(</span><span class="n">_node1</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre1</span><span class="p">,</span> <span class="n">cost1</span><span class="p">)),</span> <span class="p">(</span><span class="n">_node2</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre2</span><span class="p">,</span> <span class="n">cost2</span><span class="p">))|</span> <span class="n">cost1</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cost2</span><span class="p">))</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find next node"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.0</span>
            <span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">predecessor</span><span class="p">,</span> <span class="n">_old_estimate</span><span class="p">))</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.remove_entry</span><span class="p">(</span><span class="n">next_best_node</span><span class="p">)</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find predecessor"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">cost_of_predecessor</span> <span class="o">=</span> <span class="n">connections</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">predecessor</span><span class="nf">.as_node</span><span class="p">())</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"predecessor has not been visited"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.1</span><span class="p">;</span>

        <span class="c1">// Add point to resulting path.</span>
        <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span><span class="n">next_best_node</span><span class="p">,</span> <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">predecessor</span><span class="p">),</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

        <span class="c1">// Add neighbours of point to list of checkable values.</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">next_best_node</span><span class="nf">.neighbours</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">estimate</span> <span class="o">=</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="nf">estimator</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">previous_best</span> <span class="o">=</span> <span class="n">checkable</span>
                    <span class="nf">.get</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
                    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">))</span>
                    <span class="na">.1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">previous_best</span> <span class="o">&gt;</span> <span class="n">estimate</span> <span class="p">{</span>
                    <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">next_best_node</span><span class="nf">.pos</span><span class="p">(),</span> <span class="n">estimate</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="c1">// connections.insert(neigh_node, Some(start.pos()));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">build_graph</span><span class="p">(</span>
    <span class="n">lava</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span>
    <span class="n">max</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">graph</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">min</span><span class="py">.x</span><span class="o">..=</span><span class="n">max</span><span class="py">.x</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">min</span><span class="py">.y</span><span class="o">..=</span><span class="n">max</span><span class="py">.y</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">z</span> <span class="k">in</span> <span class="n">min</span><span class="py">.z</span><span class="o">..=</span><span class="n">max</span><span class="py">.z</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">point</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">};</span>
                <span class="c1">// Ignore points that are themselves lava.</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lava</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// Find all neihhbours, which are points that are still within the boundaries and</span>
                <span class="c1">// not lava.</span>
                <span class="k">let</span> <span class="n">neighbours</span> <span class="o">=</span> <span class="n">point</span>
                    <span class="nf">.env</span><span class="p">()</span>
                    <span class="nf">.into_iter</span><span class="p">()</span>
                    <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
                        <span class="c1">// The point does not contain lava.</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nb">None</span> <span class="o">=</span> <span class="n">lava</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="p">)</span> <span class="p">{</span>
                            <span class="c1">// The point is still within the cube boundaries.</span>
                            <span class="k">if</span> <span class="n">el</span><span class="py">.x</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="py">.x</span>
                                <span class="o">&amp;&amp;</span> <span class="n">el</span><span class="py">.x</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="py">.x</span>
                                <span class="o">&amp;&amp;</span> <span class="n">el</span><span class="py">.y</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="py">.y</span>
                                <span class="o">&amp;&amp;</span> <span class="n">el</span><span class="py">.y</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="py">.y</span>
                                <span class="o">&amp;&amp;</span> <span class="n">el</span><span class="py">.z</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="py">.z</span>
                                <span class="o">&amp;&amp;</span> <span class="n">el</span><span class="py">.z</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="py">.z</span>
                            <span class="p">{</span>
                                <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="nb">None</span>
                            <span class="p">}</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nb">None</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                    <span class="nf">.collect</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span>
                    <span class="n">p</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span>
                    <span class="n">neighbours</span><span class="p">,</span>
                <span class="p">};</span>
                <span class="n">graph</span><span class="nf">.insert</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">graph</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">lava_lines</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"pos"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Part 1.</span>

    <span class="k">let</span> <span class="n">lava</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">lava_lines</span><span class="nf">.into_iter</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">surface_area_part1</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.env</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">!</span><span class="n">lava</span><span class="nf">.contains</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
        <span class="nf">.count</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"for part 1, the surface area is {}"</span><span class="p">,</span> <span class="n">surface_area_part1</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="k">let</span> <span class="n">min_x</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"min x"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"max x"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"min y"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"max y"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">min_z</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.z</span><span class="p">)</span>
        <span class="nf">.min</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"min z"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_z</span> <span class="o">=</span> <span class="n">lava</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.z</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"max z"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">min</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">min_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">min_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">min_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="c1">// Max is also the target for the pahtfinding algorithm.</span>
    <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">max_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">max_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">max_z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// Construct graph that does not contain diagonal connections.</span>
    <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nf">build_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lava</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">);</span>
    <span class="c1">// This is the heuristic needed for A*.</span>
    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="n">node</span><span class="nf">.infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_point</span><span class="p">);</span>
    <span class="c1">// Define the end point of the paht finding.</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max</span><span class="nf">.as_node</span><span class="p">())</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find end node in graph"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// println!("{:?}", graph);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">air_pockets</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">no_air_pockets</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">min</span><span class="py">.x</span><span class="o">..=</span><span class="n">max</span><span class="py">.x</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">min</span><span class="py">.y</span><span class="o">..=</span><span class="n">max</span><span class="py">.y</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">z</span> <span class="k">in</span> <span class="n">min</span><span class="py">.z</span><span class="o">..=</span><span class="n">max</span><span class="py">.z</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">start_point</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">};</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lava</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Do not try to find paths that start at lava.</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">air_pockets</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Do not try to find paths that start at air pockets.</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">no_air_pockets</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_point</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Do not try to find paths that start at a connected point.</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span>
                    <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_point</span><span class="nf">.as_node</span><span class="p">())</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find start node in graph"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
                <span class="c1">// try to find the path to the max node.</span>
                <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="c1">// If the end node is not in the found path, we discovered an air pocket.</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nb">None</span> <span class="o">=</span> <span class="n">path</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">air_pockets</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">air_pockets</span> <span class="p">|</span> <span class="o">&amp;</span><span class="n">path</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="py">.p</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">no_air_pockets</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">no_air_pockets</span> <span class="p">|</span> <span class="o">&amp;</span><span class="n">path</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="py">.p</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">lava_with_filled_pockets</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lava</span> <span class="p">|</span> <span class="o">&amp;</span><span class="n">air_pockets</span><span class="p">;</span>

    <span class="c1">// println!("{} =&gt; {:?} {:?}", lava.len(), min, max,);</span>

    <span class="k">let</span> <span class="n">surface_area_part2</span> <span class="o">=</span> <span class="n">lava_with_filled_pockets</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.env</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">())</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">!</span><span class="n">lava_with_filled_pockets</span><span class="nf">.contains</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
        <span class="nf">.count</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"for part 2, the surface area is {}"</span><span class="p">,</span> <span class="n">surface_area_part2</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">z</span><span class="p">:</span> <span class="nb">i8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
            <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span> <span class="o">+</span> <span class="n">other</span><span class="py">.z</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="k">self</span><span class="py">.z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="o">*</span><span class="k">self</span><span class="p">,</span>
            <span class="n">neighbours</span><span class="p">:</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse pos"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">neighbours</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pos</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">neighbours</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.neighbours</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.p.x</span> <span class="o">-</span> <span class="n">other</span><span class="py">.x</span><span class="p">)</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span>
            <span class="o">+</span> <span class="p">(</span><span class="k">self</span><span class="py">.p.y</span> <span class="o">-</span> <span class="n">other</span><span class="py">.y</span><span class="p">)</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span>
            <span class="o">+</span> <span class="p">(</span><span class="k">self</span><span class="py">.p.z</span> <span class="o">-</span> <span class="n">other</span><span class="py">.z</span><span class="p">)</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// We identify a node only by its position.</span>
<span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span><span class="nf">.hash</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span> <span class="o">==</span> <span class="n">other</span><span class="py">.p</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_18">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-19">Day 19: Not Enough Minerals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_17">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_18">Solution</h3>
<div class="paragraph">
<p>Today, I first went on a wild goose chase because I had a fancy idea, which
totally didn&#8217;t work out but cost quite a bit of time.
My second attempt was thus a straightforward implementation of the instructions
with a cache because state values often reapeat themselves.
The cache associates each world state with its best geode value.
Note that a state includes the remaining simulation time.
Thus, if we find a value that&#8217;s in the cache, we can avoid go compute the same
world progression again because the state uniquely identifies how the world will
progress from that point on.</p>
</div>
<div class="paragraph">
<p>In my input for part 1, there was one blueprint that didn&#8217;t work out with a
straightforward implementation of the cache.
That is, the cache grew so large that my computer ran out of RAM.
Thus, I only cached values until some time steps before the end.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>
<span class="k">const</span> <span class="n">LRU_THRESHOLD</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">is_env</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">def</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">def</span><span class="nf">.to_string</span><span class="p">())</span> <span class="o">==</span> <span class="n">val</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">exhaustive_search</span><span class="p">(</span>
    <span class="n">state</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">State</span><span class="p">,</span>
    <span class="n">bp</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Blueprint</span><span class="p">,</span>
    <span class="n">actions</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">WhatToBuild</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lru</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">State</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">total_best</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">state</span><span class="py">.time</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="py">.geode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">state</span><span class="py">.time</span> <span class="o">&gt;=</span> <span class="n">LRU_THRESHOLD</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">lru_val</span><span class="p">)</span> <span class="o">=</span> <span class="n">lru</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">lru_val</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">state</span><span class="py">.geode</span> <span class="o">+</span> <span class="n">state</span><span class="py">.time</span> <span class="o">*</span> <span class="n">state</span><span class="py">.geode_robots</span> <span class="o">+</span> <span class="p">(</span><span class="n">state</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">&lt;</span> <span class="o">*</span><span class="n">total_best</span>
    <span class="p">{</span>
        <span class="c1">// Return early if a very optimistic estimate of what we can still achieve is lower than</span>
        <span class="c1">// the best we've already found.</span>
        <span class="k">return</span> <span class="n">state</span><span class="py">.geode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">best</span> <span class="o">=</span> <span class="n">state</span><span class="py">.geode</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">act</span> <span class="k">in</span> <span class="n">actions</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="nf">.next</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">act</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">possible_best</span> <span class="o">=</span> <span class="nf">exhaustive_search</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">lru</span><span class="p">,</span> <span class="n">total_best</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">possible_best</span> <span class="o">&gt;</span> <span class="n">best</span> <span class="p">{</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">possible_best</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">best</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">total_best</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">total_best</span> <span class="o">=</span> <span class="n">best</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Remember the value we found, but only for early ones.</span>
    <span class="k">if</span> <span class="n">state</span><span class="py">.time</span> <span class="o">&gt;=</span> <span class="n">LRU_THRESHOLD</span> <span class="p">{</span>
        <span class="n">lru</span><span class="nf">.insert</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">best</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">best</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">blueprints</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Blueprint</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"blueprint"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">actions</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">GeodeR</span><span class="p">,</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">ObsidianR</span><span class="p">,</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">ClayR</span><span class="p">,</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">OreR</span><span class="p">,</span>
        <span class="nn">data</span><span class="p">::</span><span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">Nothing</span><span class="p">,</span>
    <span class="p">];</span>

    <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">best_vals</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span> <span class="k">in</span> <span class="n">blueprints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lru</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">State</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">State</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">best_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">best</span> <span class="o">=</span> <span class="nf">exhaustive_search</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actions</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">best_cache</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"best for {} is {}"</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">best</span><span class="p">);</span>
            <span class="n">best_vals</span><span class="nf">.push</span><span class="p">(</span><span class="n">best</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">quality_level</span> <span class="o">=</span> <span class="n">best_vals</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.zip</span><span class="p">(</span><span class="n">blueprints</span><span class="nf">.iter</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">val</span><span class="p">,</span> <span class="n">bp</span><span class="p">)|</span> <span class="n">bp</span><span class="py">.id</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">*</span> <span class="n">val</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
            <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"the overall quality level is: {}"</span><span class="p">,</span> <span class="n">quality_level</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">best_vals</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span> <span class="k">in</span> <span class="n">blueprints</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.take</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Sadly, we cannot reuse the LRU cache for other blueprints.</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lru</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">State</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">best_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">State</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">best</span> <span class="o">=</span> <span class="nf">exhaustive_search</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actions</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">best_cache</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"best for {} is {}"</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">best</span><span class="p">);</span>
            <span class="n">best_vals</span><span class="nf">.push</span><span class="p">(</span><span class="n">best</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">quality_level</span> <span class="o">=</span> <span class="n">best_vals</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
            <span class="py">.product</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"the overall quality level is: {}"</span><span class="p">,</span> <span class="n">quality_level</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nf">is_env</span><span class="p">(</span><span class="s">"RUN"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">rand</span><span class="p">::</span><span class="nn">distributions</span><span class="p">::{</span><span class="n">Distribution</span><span class="p">,</span> <span class="n">Standard</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">rand</span><span class="p">::</span><span class="n">Rng</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Size</span> <span class="o">=</span> <span class="nb">u16</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Blueprint</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">id</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">ore_ore_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">clay_ore_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">obsidian_ore_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">obsidian_clay_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">geode_ore_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">geode_obsidian_cost</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">WhatToBuild</span> <span class="p">{</span>
    <span class="n">OreR</span><span class="p">,</span>
    <span class="n">ClayR</span><span class="p">,</span>
    <span class="n">ObsidianR</span><span class="p">,</span>
    <span class="n">GeodeR</span><span class="p">,</span>
    <span class="n">Nothing</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Blueprint</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="s">"Blueprint"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s">"Each"</span><span class="p">,</span> <span class="s">"ore"</span><span class="p">,</span> <span class="s">"robot"</span><span class="p">,</span> <span class="s">"costs"</span><span class="p">,</span> <span class="n">ore_ore_cost</span><span class="p">,</span> <span class="s">"ore."</span><span class="p">,</span> <span class="s">"Each"</span><span class="p">,</span> <span class="s">"clay"</span><span class="p">,</span> <span class="s">"robot"</span><span class="p">,</span> <span class="s">"costs"</span><span class="p">,</span> <span class="n">clay_ore_cost</span><span class="p">,</span> <span class="s">"ore."</span><span class="p">,</span> <span class="s">"Each"</span><span class="p">,</span> <span class="s">"obsidian"</span><span class="p">,</span> <span class="s">"robot"</span><span class="p">,</span> <span class="s">"costs"</span><span class="p">,</span> <span class="n">obsidian_ore_cost</span><span class="p">,</span> <span class="s">"ore"</span><span class="p">,</span> <span class="s">"and"</span><span class="p">,</span> <span class="n">obsidian_clay_cost</span><span class="p">,</span> <span class="s">"clay."</span><span class="p">,</span> <span class="s">"Each"</span><span class="p">,</span> <span class="s">"geode"</span><span class="p">,</span> <span class="s">"robot"</span><span class="p">,</span> <span class="s">"costs"</span><span class="p">,</span> <span class="n">geode_ore_cost</span><span class="p">,</span> <span class="s">"ore"</span><span class="p">,</span> <span class="s">"and"</span><span class="p">,</span> <span class="n">geode_obsidian_cost</span><span class="p">,</span> <span class="s">"obsidian."</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                    <span class="n">id</span><span class="p">:</span> <span class="n">id</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">ore_ore_cost</span><span class="p">:</span> <span class="n">ore_ore_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">clay_ore_cost</span><span class="p">:</span> <span class="n">clay_ore_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">obsidian_ore_cost</span><span class="p">:</span> <span class="n">obsidian_ore_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">obsidian_clay_cost</span><span class="p">:</span> <span class="n">obsidian_clay_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">geode_ore_cost</span><span class="p">:</span> <span class="n">geode_ore_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">geode_obsidian_cost</span><span class="p">:</span> <span class="n">geode_obsidian_cost</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse blueprint"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Hash)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">time</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">ore</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">ore_robots</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">clay</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">clay_robots</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">obsidian</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">obsidian_robots</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">geode</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">geode_robots</span><span class="p">:</span> <span class="n">Size</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">available_time</span><span class="p">:</span> <span class="n">Size</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">time</span><span class="p">:</span> <span class="n">available_time</span><span class="p">,</span>
            <span class="n">ore</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">ore_robots</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">clay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">clay_robots</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">obsidian</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">obsidian_robots</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">geode</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">geode_robots</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">bp</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Blueprint</span><span class="p">,</span> <span class="n">act</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">WhatToBuild</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Only perform the drawn operation if we have enough resources for it. Otherwise,</span>
        <span class="c1">// implicitly perform a "nothing" operation.</span>
        <span class="k">match</span> <span class="n">act</span> <span class="p">{</span>
            <span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">Nothing</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                    <span class="n">time</span><span class="p">:</span> <span class="k">self</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="c1">// Materials.</span>
                    <span class="n">ore</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ore_robots</span><span class="p">,</span>
                    <span class="n">clay</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">+</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                    <span class="n">obsidian</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">+</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                    <span class="n">geode</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode</span> <span class="o">+</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                    <span class="c1">// Robots.</span>
                    <span class="n">ore_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore_robots</span><span class="p">,</span>
                    <span class="n">clay_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                    <span class="n">obsidian_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                    <span class="n">geode_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">}</span>
            <span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">OreR</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.ore_ore_cost</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">time</span><span class="p">:</span> <span class="k">self</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="c1">// Materials.</span>
                        <span class="n">ore</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ore_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.ore_ore_cost</span><span class="p">,</span>
                        <span class="n">clay</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">+</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">+</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode</span> <span class="o">+</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                        <span class="c1">// Robots.</span>
                        <span class="n">ore_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore_robots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">clay_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">ClayR</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.clay_ore_cost</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">time</span><span class="p">:</span> <span class="k">self</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="c1">// Materials.</span>
                        <span class="n">ore</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ore_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.clay_ore_cost</span><span class="p">,</span>
                        <span class="n">clay</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">+</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">+</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode</span> <span class="o">+</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                        <span class="c1">// Robots.</span>
                        <span class="n">ore_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore_robots</span><span class="p">,</span>
                        <span class="n">clay_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay_robots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">obsidian_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">ObsidianR</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.obsidian_ore_cost</span> <span class="p">||</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.obsidian_clay_cost</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">time</span><span class="p">:</span> <span class="k">self</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="c1">// Materials.</span>
                        <span class="n">ore</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ore_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.obsidian_ore_cost</span><span class="p">,</span>
                        <span class="n">clay</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">+</span> <span class="k">self</span><span class="py">.clay_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.obsidian_clay_cost</span><span class="p">,</span>
                        <span class="n">obsidian</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">+</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode</span> <span class="o">+</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                        <span class="c1">// Robots.</span>
                        <span class="n">ore_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore_robots</span><span class="p">,</span>
                        <span class="n">clay_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian_robots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">geode_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">WhatToBuild</span><span class="p">::</span><span class="n">GeodeR</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.geode_ore_cost</span> <span class="p">||</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="py">.geode_obsidian_cost</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">time</span><span class="p">:</span> <span class="k">self</span><span class="py">.time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="c1">// Materials.</span>
                        <span class="n">ore</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ore_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.geode_ore_cost</span><span class="p">,</span>
                        <span class="n">clay</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay</span> <span class="o">+</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian</span> <span class="o">+</span> <span class="k">self</span><span class="py">.obsidian_robots</span> <span class="o">-</span> <span class="n">bp</span><span class="py">.geode_obsidian_cost</span><span class="p">,</span>
                        <span class="n">geode</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode</span> <span class="o">+</span> <span class="k">self</span><span class="py">.geode_robots</span><span class="p">,</span>
                        <span class="c1">// Robots.</span>
                        <span class="n">ore_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.ore_robots</span><span class="p">,</span>
                        <span class="n">clay_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.clay_robots</span><span class="p">,</span>
                        <span class="n">obsidian_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.obsidian_robots</span><span class="p">,</span>
                        <span class="n">geode_robots</span><span class="p">:</span> <span class="k">self</span><span class="py">.geode_robots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_19">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-20">Day 20: Grove Positioning System</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_18">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_19">Solution</h3>
<div class="paragraph">
<p>Today was both frustrating and nice.
At first, I came up with a complex approach that used an index map and its
reverse to keep track of where an element was originally and where it is right
now.
But then I realised that rust&#8217;s vectors have an <code>insert</code> and a <code>remove</code> method
that does just what was needed here.
Luckily, I discarded my first idea pretty quickly.</p>
</div>
<div class="paragraph">
<p>Furthermore, as I discovered during one of the previous days, an iterator over a
vector in rust can be made infinite via the <code>cyclic</code> method.
Thus, for part 1, I didn&#8217;t have to care about the cyclic nature of the problem.
In fact, the vector I get in the end doesn&#8217;t look like the one online, but it
also doesn&#8217;t have to.
It&#8217;s just that each element has to have the same neighbours as in the example,
which they do.</p>
</div>
<div class="paragraph">
<p>What I do is I keep a vector that consists of a tuple of the actual number and
its original index.
I use that original index to find the number in the vector when it&#8217;s its turn to
be mixed.
That&#8217;s basically part 1.
At first, I made a stupid mistake when extracting the three numbers that make up
the grove coordinates and took the first three in steps of one thousand but
<em>including</em> zero.
Unfortunately, I tried for quite a bit to apply a fix to the wrong location.</p>
</div>
<div class="paragraph">
<p>Part 2 was just like part 1 but with some modulo operations applied.
You just need to be careful to take the modulus with respect to the length of
the file reduced by one.
For more details, please see the code.
I added extensive comments.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">mixes</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">decryption_key</span><span class="p">:</span> <span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data. We use a custom struct here just so we can continue using</span>
    <span class="c1">// our parser function.</span>
    <span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Num</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"blueprint"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Convert custom struct into vector of primitive types.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">file</span> <span class="o">=</span> <span class="n">nums</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="c1">// For part 1, the decryption_key is 1.</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.num</span><span class="p">()</span> <span class="o">*</span> <span class="n">decryption_key</span><span class="p">)</span>
        <span class="c1">// Remember the index in the original list. This is used to find the data point later on</span>
        <span class="c1">// based on its index in the original input.</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// Two convenience values that will be used further down.</span>
    <span class="c1">// Let's always remember how many values there were originally.</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.len</span><span class="p">();</span>
    <span class="c1">// After removing an element from the vector, this is gonna be its length. Thus, this is the</span>
    <span class="c1">// value with respect to which we need to take the modulus when deciding how many cycles to</span>
    <span class="c1">// skip.</span>
    <span class="k">let</span> <span class="n">mod_me</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// We will be mixing `mixes` times.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">mixes</span> <span class="p">{</span>
        <span class="c1">// We will keep mixing in the originalorder.</span>
        <span class="k">for</span> <span class="n">org_idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="p">{</span>
            <span class="c1">// Find the element that was at `org_idx` in the initial input and remember its value</span>
            <span class="c1">// and current index.</span>
            <span class="k">let</span> <span class="n">move_me_data</span> <span class="o">=</span> <span class="n">file</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span> <span class="o">==</span> <span class="n">org_idx</span><span class="p">)</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find element"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

            <span class="c1">// Zero doesn't move so we skip it.</span>
            <span class="k">if</span> <span class="n">file</span><span class="p">[</span><span class="n">move_me_data</span><span class="p">]</span><span class="na">.1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Remove the element from the vector. When imagining the cyclic list, it becomes clear</span>
            <span class="c1">// that a number will never encounter itself. Thus, it is the same as if we were</span>
            <span class="c1">// moving through an infinite vector that doesn't contain the number.</span>
            <span class="k">let</span> <span class="n">move_me</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.remove</span><span class="p">(</span><span class="n">move_me_data</span><span class="p">);</span>
            <span class="c1">// Below, we use a nice feature of Rust's iterators over vectors, namely that they can</span>
            <span class="c1">// be cyclic. Thus, we don't actually care whether our resulting vector looks as it</span>
            <span class="c1">// does in the example because it is cyclic anyway.</span>
            <span class="k">if</span> <span class="n">move_me</span><span class="na">.1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// Move to the left. Here, we iterate through the vector backwards.</span>
                <span class="k">let</span> <span class="n">prev_elem_pos</span> <span class="o">=</span> <span class="n">file</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.enumerate</span><span class="p">()</span>
                    <span class="c1">// Reverse the iterator's direction here.</span>
                    <span class="nf">.rev</span><span class="p">()</span>
                    <span class="c1">// Turn it into an inifinte iterator. Thus, we won't have to care about</span>
                    <span class="c1">// wrap-arounds.</span>
                    <span class="nf">.cycle</span><span class="p">()</span>
                    <span class="c1">// Skip as many elements until we are at the location of the element we just</span>
                    <span class="c1">// removed. Doing so when moving backwards is a bit of a hassle but it works.</span>
                    <span class="nf">.skip</span><span class="p">(</span><span class="n">file</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">move_me_data</span><span class="p">)</span>
                    <span class="c1">// Skip as often as we need to according to the value of the number.</span>
                    <span class="c1">// Make this efficient by taking the modulus with respect to the current length</span>
                    <span class="c1">// of the vector.</span>
                    <span class="nf">.skip</span><span class="p">((</span><span class="n">move_me</span><span class="na">.1</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod_me</span><span class="p">)</span>
                    <span class="c1">// Get the next element in the iterator, which is the element that is currently</span>
                    <span class="c1">// just before the position we want our removed element to occupy.</span>
                    <span class="nf">.next</span><span class="p">()</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"this should be infinite"</span><span class="p">))</span><span class="o">?</span>
                    <span class="na">.0</span><span class="p">;</span>

                <span class="c1">// Insert after the element we just found. Thanks, Rust, that `insert` also works</span>
                <span class="c1">// if the position where we want to insert is one past the end.</span>
                <span class="n">file</span><span class="nf">.insert</span><span class="p">((</span><span class="n">prev_elem_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.rem_euclid</span><span class="p">(</span><span class="n">file</span><span class="nf">.len</span><span class="p">()),</span> <span class="n">move_me</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">move_me</span><span class="na">.1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// Move to the right. Here, we iterate in forward direction.</span>
                <span class="k">let</span> <span class="n">next_elem_pos</span> <span class="o">=</span> <span class="n">file</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.enumerate</span><span class="p">()</span>
                    <span class="c1">// Turn it into an inifinte iterator. Thus, we won't have to care about</span>
                    <span class="c1">// wrap-arounds.</span>
                    <span class="nf">.cycle</span><span class="p">()</span>
                    <span class="c1">// Skip as many elements until we are at the location of the element we just</span>
                    <span class="c1">// removed.</span>
                    <span class="nf">.skip</span><span class="p">(</span><span class="n">move_me_data</span><span class="p">)</span>
                    <span class="c1">// Skip as often as we need to according to the value of the number.</span>
                    <span class="c1">// Make this efficient by taking the modulus with respect to the current length</span>
                    <span class="c1">// of the vector.</span>
                    <span class="nf">.skip</span><span class="p">((</span><span class="n">move_me</span><span class="na">.1</span><span class="nf">.abs</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod_me</span><span class="p">)</span>
                    <span class="c1">// Get the next element, which is the element that is currently at the position</span>
                    <span class="c1">// we want our removed element to occupy.</span>
                    <span class="nf">.next</span><span class="p">()</span>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"this should be infinite"</span><span class="p">))</span><span class="o">?</span>
                    <span class="na">.0</span><span class="p">;</span>

                <span class="c1">// Insert at the position of the element we just found.</span>
                <span class="n">file</span><span class="nf">.insert</span><span class="p">(</span><span class="n">next_elem_pos</span><span class="p">,</span> <span class="n">move_me</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"there are no more numbers"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Extract the desired sum in a lazy way. Simply iterate 1, 2 and 3 thousand times over an ever</span>
    <span class="c1">// repeating instance of our iterator.</span>
    <span class="c1">//</span>
    <span class="c1">// Find the index of 0 first. This helps with debugging in case 0 is removed by accident.</span>
    <span class="k">let</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="n">file</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.find_map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">num</span><span class="p">))|</span> <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="o">&amp;</span><span class="mi">0</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">})</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find zero"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// Then take the sum.</span>
    <span class="k">let</span> <span class="n">grove_coords</span> <span class="o">=</span> <span class="n">file</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="c1">// Take apart so that we only keep the data. We no longer care about original indices.</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">_idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="n">el</span><span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="c1">// Infinite iterators again.</span>
        <span class="nf">.cycle</span><span class="p">()</span>
        <span class="c1">// Skip until we are at the location of 0.</span>
        <span class="nf">.skip</span><span class="p">(</span><span class="n">start_idx</span><span class="p">)</span>
        <span class="c1">// Find current indices.</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="c1">// Take only every 1000'th element after zero. Note that 0 also passes here.</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">el</span><span class="p">)|</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">})</span>
        <span class="c1">// We take 4 here because the first one fulfilling the condition will be zero.</span>
        <span class="nf">.take</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1">// Skip zero.</span>
        <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Size</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"solution for {} mix(es) and a key of {} is {}"</span><span class="p">,</span>
        <span class="n">mixes</span><span class="p">,</span> <span class="n">decryption_key</span><span class="p">,</span> <span class="n">grove_coords</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">811_589_153</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">811_589_153</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">Size</span> <span class="o">=</span> <span class="nb">i64</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Num</span><span class="p">(</span><span class="n">Size</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">Num</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Size</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Num</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">(</span><span class="n">s</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_20">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-21">Day 21: Monkey Math</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_19">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_20">Solution</h3>
<div class="paragraph">
<p>No time to explain, barely enough time to implement.</p>
</div>
<div class="paragraph">
<p>Part 1 is straightforward, simply fill in all monkey values that you can each
round until you found the value for <code>root</code>.</p>
</div>
<div class="paragraph">
<p>Part 2 was more tricky.
Looking at the data, it becomes clear that only one side of the equation depends
on the human&#8217;s value while the other one is constant.
My code determines that side automatically.</p>
</div>
<div class="paragraph">
<p>Furthermore, you need to realise that the value of the other side changes
monotonically depending on the human&#8217;s value.
Then, it&#8217;s a simple search over the available parameter space.
I opted for a search with more steps than a binary search and it works well
enough for my inputs.
I also assume that the number we need to shout is positive since all monkeys
shout positive values themselves.
That might not hold for all inputs.</p>
</div>
<div class="paragraph">
<p>My solytion might not work for all inputs but it should be easy to fix.
I added some checks that panic if they fail in orer to catch edge cases but
those didn&#8217;t occur for me.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="nf">do_op</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="n">val1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">,</span> <span class="n">val2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'+'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">val1</span> <span class="o">-</span> <span class="n">val2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">val1</span> <span class="o">*</span> <span class="n">val2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">val1</span> <span class="o">/</span> <span class="n">val2</span><span class="p">,</span> <span class="n">val1</span> <span class="o">%</span> <span class="n">val2</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"unknown op"</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">do_op_str</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="n">str1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">str2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'*'</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}*{}"</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"({}+{})"</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">),</span>
        <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"({}-{})"</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">),</span>
        <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"({}/{})"</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"unknown op"</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">monkeys_again</span><span class="p">(</span>
    <span class="n">monkeys</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Monkey</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">human</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">part1</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">,</span> <span class="nb">char</span><span class="p">,</span> <span class="nb">isize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A map from monkey names to their numbers for those monkeys that already know them.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">known</span> <span class="o">=</span> <span class="n">monkeys</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Action</span><span class="p">::</span><span class="nf">Shout</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="py">.action</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">el</span><span class="py">.name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">num</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">part1</span> <span class="p">{</span>
        <span class="n">known</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"humn"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">human</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// We use this to determine which side of part 2's root equation is independent of the human</span>
    <span class="c1">// value.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">known_str</span> <span class="o">=</span> <span class="n">monkeys</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Action</span><span class="p">::</span><span class="nf">Shout</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="py">.action</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">el</span><span class="py">.name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">)))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="n">known_str</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"humn"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"humn"</span><span class="nf">.to_string</span><span class="p">());</span>

    <span class="c1">// A map from monkey names to their ops for those monkeys that don't yet know their numbers.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">unknown</span> <span class="o">=</span> <span class="n">monkeys</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Action</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">mon1</span><span class="p">,</span> <span class="n">mon2</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">el</span><span class="py">.action</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">known</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="py">.name</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">((</span><span class="n">el</span><span class="py">.name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="p">(</span><span class="n">mon1</span><span class="p">,</span> <span class="n">mon2</span><span class="p">,</span> <span class="n">op</span><span class="p">)))</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">root_name</span> <span class="o">=</span> <span class="s">"root"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">largest_remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">unknown</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">moved</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">mon1</span><span class="p">,</span> <span class="n">mon2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">))</span> <span class="k">in</span> <span class="n">unknown</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="o">=</span> <span class="n">known</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon1</span><span class="nf">.as_str</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">known</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon2</span><span class="nf">.as_str</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root_name</span> <span class="p">{</span>
                        <span class="c1">// We've reached the end.</span>
                        <span class="k">if</span> <span class="o">!</span><span class="n">part1</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="nf">Ok</span><span class="p">((</span><span class="o">*</span><span class="n">val1</span><span class="p">,</span> <span class="o">*</span><span class="n">val2</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">largest_remainder</span><span class="p">,</span> <span class="k">false</span><span class="p">));</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">known_str</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon1</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"mon1 not found"</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">known_str</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon2</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"mon2 not found"</span><span class="p">);</span>

                            <span class="k">let</span> <span class="n">left_has_human</span> <span class="o">=</span> <span class="k">if</span> <span class="o">!</span><span class="n">str1</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"humn"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">str2</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"humn"</span><span class="p">)</span>
                            <span class="p">{</span>
                                <span class="k">false</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">str1</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"humn"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">str2</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"humn"</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">true</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"neither side depends on the human"</span><span class="p">));</span>
                            <span class="p">};</span>
                            <span class="k">return</span> <span class="nf">Ok</span><span class="p">((</span><span class="o">*</span><span class="n">val1</span><span class="p">,</span> <span class="o">*</span><span class="n">val2</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">largest_remainder</span><span class="p">,</span> <span class="n">left_has_human</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">do_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
                        <span class="k">if</span> <span class="n">result</span><span class="na">.1</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">largest_remainder</span> <span class="p">{</span>
                            <span class="n">largest_remainder</span> <span class="o">=</span> <span class="n">result</span><span class="na">.1</span><span class="nf">.abs</span><span class="p">();</span>
                        <span class="p">}</span>
                        <span class="n">known</span><span class="nf">.insert</span><span class="p">(</span><span class="n">name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">result</span><span class="na">.0</span><span class="p">);</span>
                        <span class="c1">// Handle string representation.</span>
                        <span class="k">if</span> <span class="n">part1</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">known_str</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon1</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"mon1 not found"</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">known_str</span><span class="nf">.get</span><span class="p">(</span><span class="n">mon2</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"mon2 not found"</span><span class="p">);</span>
                            <span class="n">known_str</span><span class="nf">.insert</span><span class="p">(</span><span class="n">name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">do_op_str</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">));</span>
                        <span class="p">}</span>
                        <span class="c1">// We will remove the ones in thos vector from the map of unknown values.</span>
                        <span class="n">moved</span><span class="nf">.push</span><span class="p">(</span><span class="n">name</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">now_known</span> <span class="k">in</span> <span class="n">moved</span> <span class="p">{</span>
            <span class="n">unknown</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_known</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"we didn't find the root monkey"</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data. We use a custom struct here just so we can continue using</span>
    <span class="c1">// our parser function.</span>
    <span class="k">let</span> <span class="n">monkeys</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Monkey</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"monkey"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">left_root_val</span><span class="p">,</span> <span class="n">right_root_val</span><span class="p">,</span> <span class="n">root_op</span><span class="p">,</span> <span class="n">largest_remainder</span><span class="p">,</span> <span class="n">left_has_human</span><span class="p">)</span> <span class="o">=</span>
        <span class="nf">monkeys_again</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monkeys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">largest_remainder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"remainder is zero"</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span>
        <span class="n">left_has_human</span><span class="p">,</span>
        <span class="s">"right value is constant, swap left and right values if it isn't"</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">root_val</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">do_op</span><span class="p">(</span><span class="n">root_op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left_root_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right_root_val</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"root's value is {}"</span><span class="p">,</span> <span class="n">root_val</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1_000_000_000_000</span><span class="p">;</span>

    <span class="c1">// This is hacky but it works. We assume a certain ordering for the left and right values at</span>
    <span class="c1">// zero. If the ordering is not what we expect, we simply multiply both sides by -1, which</span>
    <span class="c1">// "fixes" the ordering.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">zero_left_root_val</span><span class="p">,</span> <span class="n">zero_right_root_val</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">monkeys_again</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monkeys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">inv</span> <span class="o">=</span> <span class="k">if</span> <span class="n">zero_left_root_val</span> <span class="o">&gt;</span> <span class="n">zero_right_root_val</span> <span class="p">{</span>
        <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">};</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// We assume the number we need to shout is positive.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">check</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">found</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="n">check</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">left_root_val</span><span class="p">,</span> <span class="n">right_root_val</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">largest_remainder</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
            <span class="nf">monkeys_again</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monkeys</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// println!("{} == {}", left_root_val, right_root_val);</span>
        <span class="k">match</span> <span class="p">(</span><span class="n">inv</span> <span class="o">*</span> <span class="n">left_root_val</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">inv</span> <span class="o">*</span> <span class="n">right_root_val</span><span class="p">))</span> <span class="p">{</span>
            <span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">largest_remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                    <span class="nd">println!</span><span class="p">(</span><span class="s">"we need to shout {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">panic!</span><span class="p">(</span><span class="s">"we found a non-zero remainder"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">check</span> <span class="o">-=</span> <span class="n">step</span><span class="p">;</span>
                <span class="n">step</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">check</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Monkey</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">action</span><span class="p">:</span> <span class="n">Action</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Action</span> <span class="p">{</span>
    <span class="nf">Shout</span><span class="p">(</span><span class="nb">isize</span><span class="p">),</span>
    <span class="nf">Op</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">,</span> <span class="nb">char</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Monkey</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span><span class="nf">.split_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">action</span><span class="p">:</span> <span class="nn">Action</span><span class="p">::</span><span class="nf">Shout</span><span class="p">(</span><span class="n">num</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">),</span>
            <span class="p">}),</span>
            <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">mon1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">mon2</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">op</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span><span class="nf">.to_string</span><span class="p">(),</span>
                        <span class="n">action</span><span class="p">:</span> <span class="nn">Action</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span>
                            <span class="n">mon1</span><span class="nf">.to_string</span><span class="p">(),</span>
                            <span class="n">mon2</span><span class="nf">.to_string</span><span class="p">(),</span>
                            <span class="n">op</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"empty op detected"</span><span class="p">))</span><span class="o">?</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">})</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"multi-char op detected"</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse monkey"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_21">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-22">Day 22: Monkey Map</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_20">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_21">Solution</h3>
<div class="paragraph">
<p>This one was arguably the hardest one of this AOC.
For part 1, I solved the problem by building a list of neighbours for each tile
that is either free or a wall.
You then simply follow the instruction string given.
The most important function for building th eneighbour map for part 1 searches
the map from an edge along a line to find the first tile that is free or a wall.</p>
</div>
<div class="paragraph">
<p>Part 2 coul dhave been solved by hard-coding the neighbour relations between
edges, but I didn&#8217;t want to do that, which is one of the reasons I finished this
one last and rather late.
Two main ideas come into play here:</p>
</div>
<div class="paragraph">
<p>Regarding rotation:
Assuming you have a correct neighbour map, you can then easily determine the new
rotation after a move by looking at the previous location.
If that location is "up" from your current one, then you are now facing down,
irrespective of any previous heading (holds similarly for the other directions).</p>
</div>
<div class="paragraph">
<p>Regarding the neighbour map:
I was wondering how to find out which points are neighbours to which ones.
As a human, I would fold up the map and construct a cube, which is what I did
here, too.
Because the map does not contain any cuts between neighbouring 50x50 patches
(aka cube faces in the flat map), we can make do with a simple folding
procedure.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify points belonging to each cube face and convert to 3D.
That conversion simply sets the z-coordinate to zero for now.
Also remeber an "up" or "north" vector and a normal vector for each point.</p>
</li>
<li>
<p>Identify which cube faces neighbour which other faces.</p>
</li>
<li>
<p>For each face, determine which faces need to be folded when folding down the
face to the right.
This can be determined by a breadth-first search over all face neighbours that
is blocked by the reference face.
Do the same for faces that lie downwards.</p>
</li>
<li>
<p>Construct a transformation consisting of rotation and translation that
describes the folding operation.</p>
</li>
<li>
<p>Fold all points in affected faces.</p>
</li>
<li>
<p>Rinse repeat.</p>
</li>
<li>
<p>Build the neighbour map considering that a folded neighbour&#8217;s normal vector
is identical to the difference vector expected to that neighbour if it were in
the same plane.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once you have a neighbour map, you apply the very same algorithm as in part 2
with the addition of the aforementioned rotation fix.
Also note that folded neighbours are identified by the very same location but
with different normal vectors.
Thus, the actual tile position could be found by moving a tile in the direction
of its normal vector by half a unit.</p>
</div>
<div class="paragraph">
<p>The code looks horrible because I wanted to get it done and didn&#8217;t care about
readability.
Thus, I havent' included it here.
Please feel free to check out the repo if you want to have a look.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_22">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-23">Day 23: Unstable Diffusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_21">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_22">Solution</h3>
<div class="paragraph">
<p>This feels like a variant of the famous game of life.
The solution can easily be found by dilligently following the instructions
given.
One potential pitfall could be that the elves change the directions in which
they prefer to move.
I used an infinite iterator over a vector again and make sure to skip one
element after each round.
That&#8217;s basically it.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">Cycle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="n">IntoIter</span><span class="p">;</span>
<span class="c1">// Constants.</span>

<span class="c1">// Play one round.</span>
<span class="k">fn</span> <span class="nf">game_of_elves</span><span class="p">(</span>
    <span class="n">elves</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">proposals</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Cycle</span><span class="o">&lt;</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="c1">// First half. Find out which elves might actually move by filtering out those that have no</span>
    <span class="c1">// other elf anywhere around them.</span>
    <span class="k">let</span> <span class="n">maybe_moving_elves</span> <span class="o">=</span> <span class="n">elves</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.env</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.any</span><span class="p">(|</span><span class="n">env</span><span class="p">|</span> <span class="n">elves</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">)))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.clone</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">props</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Each one of those elves proposes a spot. We propose up to 4 directions.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">prop</span> <span class="o">=</span> <span class="n">proposals</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"initnite proposals"</span><span class="p">);</span>
        <span class="n">props</span><span class="nf">.extend</span><span class="p">(</span>
            <span class="n">maybe_moving_elves</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="c1">// Only check those that haven't yet proposed something.</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">!</span><span class="n">props</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                <span class="c1">// Keep only those for whom this direction is clear.</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">el</span><span class="nf">.dir_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">)</span>
                        <span class="nf">.into_iter</span><span class="p">()</span>
                        <span class="nf">.all</span><span class="p">(|</span><span class="n">env</span><span class="p">|</span> <span class="o">!</span><span class="n">elves</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">))</span>
                <span class="p">})</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="p">(</span><span class="n">el</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">el</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">)))</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prop_count</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">prop</span> <span class="k">in</span> <span class="n">props</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">=</span> <span class="n">prop_count</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">old</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">prop_count</span><span class="nf">.insert</span><span class="p">(</span><span class="n">prop</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">was_moved</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="c1">// Second half. Only update to those positions that have been suggested exactly once.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span> <span class="k">in</span> <span class="n">props</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">prop_count</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="mi">1</span> <span class="p">{</span>
            <span class="n">elves</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf</span><span class="p">);</span>
            <span class="n">elves</span><span class="nf">.insert</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
            <span class="n">was_moved</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">was_moved</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="c1">// Also obtain max coords. Min coords are implicitly 0.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">occ_map</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chars_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"input"</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">elves</span> <span class="o">=</span> <span class="n">occ_map</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="n">tile</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">tile</span> <span class="o">==</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Input</span><span class="p">::</span><span class="n">Elf</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// This is our infinite stream of proposals.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">proposals</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">data</span><span class="p">::</span><span class="n">N</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">S</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">W</span><span class="p">,</span> <span class="nn">data</span><span class="p">::</span><span class="n">E</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.cycle</span><span class="p">();</span>

    <span class="c1">// Consider 10 rounds for part 1.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="nf">game_of_elves</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">elves</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">proposals</span><span class="p">);</span>
        <span class="c1">// Discard one element.</span>
        <span class="n">proposals</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"inf it"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">min_x</span> <span class="o">=</span> <span class="n">elves</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span><span class="nf">.min</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"no min x"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">elves</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.x</span><span class="p">)</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"no max x"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">elves</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span><span class="nf">.min</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"no min y"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">elves</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="py">.y</span><span class="p">)</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"no max y"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">min_x</span><span class="o">..=</span><span class="n">max_x</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">min_y</span><span class="o">..=</span><span class="n">max_y</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">elves</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"free field count is {}"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">round_count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">while</span> <span class="nf">game_of_elves</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">elves</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">proposals</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">proposals</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"inf it"</span><span class="p">);</span>
        <span class="n">round_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"final round count is {}"</span><span class="p">,</span> <span class="n">round_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Input</span> <span class="p">{</span>
    <span class="n">Elf</span><span class="p">,</span>
    <span class="n">Free</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">NE</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">E</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">SE</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">S</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">SW</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">W</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">NW</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

<span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">N</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NE</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">E</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SE</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SW</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">W</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NW</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">dir_env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dir</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">dir</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="n">N</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NW</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">N</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NE</span><span class="p">)],</span>
            <span class="o">&amp;</span><span class="n">E</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NE</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">E</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SE</span><span class="p">)],</span>
            <span class="o">&amp;</span><span class="n">S</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SE</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SW</span><span class="p">)],</span>
            <span class="o">&amp;</span><span class="n">W</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SW</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">W</span><span class="p">),</span> <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NW</span><span class="p">)],</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"we should never propose another direction"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Input</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"."</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">Free</span><span class="p">),</span>
            <span class="s">"#"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">Elf</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse as tile"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_23">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-24">Day 24: Blizzard Basin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_22">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_23">Solution</h3>
<div class="paragraph">
<p>The code for this one looks horrible because I copied and modified an <code>A*</code>
algorithm created for a previous day.
I basically used <code>A*</code> for finding the path but in 3 dimentions, with 2 spatial
ones and the third one being time.
Time can only increase and the list of viable next locations is generated on the
fly based on future blizzard positions.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
<span class="c1">// Constants.</span>

<span class="k">fn</span> <span class="n">find_path</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">blizz</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Blizzard</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">estimator_fn</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">start_time</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ref_point</span> <span class="o">=</span> <span class="n">end</span><span class="nf">.pos</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">|</span> <span class="nf">estimator_fn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref_point</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">get_node</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">graph</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="nf">.as_node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"node not found"</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.shift</span><span class="p">(</span><span class="n">node</span><span class="py">.t</span><span class="p">))</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">checkable</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">start_at_time</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.shift</span><span class="p">(</span><span class="n">start_time</span><span class="p">);</span>
    <span class="c1">// Add starting point to resulting path.</span>
    <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span><span class="n">start_at_time</span><span class="nf">.clone</span><span class="p">(),</span> <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// Add neighbours of starting point to list of checkable values. Ignore neighbouring points</span>
    <span class="c1">// that are not part of the graph.</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">start_at_time</span><span class="nf">.neighbours</span><span class="p">(</span><span class="n">blizz</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// Estimated costs are the most direct possible connection plus 1, since every step costs</span>
        <span class="c1">// one.</span>
        <span class="k">let</span> <span class="n">estimate</span> <span class="o">=</span> <span class="nf">estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="p">);</span>
        <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">start_at_time</span><span class="nf">.pos</span><span class="p">(),</span> <span class="n">estimate</span><span class="p">));</span>
        <span class="c1">// connections.insert(neigh_node, (Some(start_at_time.pos()), 1));</span>
    <span class="p">}</span>

    <span class="c1">// Search until we added the final node to the path or until there is nothing more to check.</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">checkable</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// Get node with minimum _estimated_ cost.</span>
        <span class="k">let</span> <span class="n">next_best_node</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.iter_mut</span><span class="p">()</span>
            <span class="c1">// Get node with minimum estimated cost.</span>
            <span class="nf">.min_by</span><span class="p">(|(</span><span class="n">_node1</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre1</span><span class="p">,</span> <span class="n">cost1</span><span class="p">)),</span> <span class="p">(</span><span class="n">_node2</span><span class="p">,</span> <span class="p">(</span><span class="n">_pre2</span><span class="p">,</span> <span class="n">cost2</span><span class="p">))|</span> <span class="n">cost1</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cost2</span><span class="p">))</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find next node"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.0</span>
            <span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">predecessor</span><span class="p">,</span> <span class="n">_old_estimate</span><span class="p">))</span> <span class="o">=</span> <span class="n">checkable</span>
            <span class="nf">.remove_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_best_node</span><span class="p">)</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find predecessor"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">cost_of_predecessor</span> <span class="o">=</span> <span class="n">connections</span>
            <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">predecessor</span><span class="nf">.as_node</span><span class="p">(</span><span class="nb">None</span><span class="p">))</span>
            <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"predecessor has not been visited"</span><span class="p">))</span><span class="o">?</span>
            <span class="na">.1</span><span class="p">;</span>

        <span class="c1">// Add point to resulting path unless we've found the end/</span>
        <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span>
            <span class="n">next_best_node</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">predecessor</span><span class="p">),</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="c1">// We've found the end. Add it in a hacky way.</span>
        <span class="k">if</span> <span class="nf">estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_best_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">connections</span><span class="nf">.insert</span><span class="p">(</span>
                <span class="n">next_best_node</span><span class="nf">.shift</span><span class="p">(</span><span class="n">end</span><span class="py">.p.t</span><span class="p">),</span>
                <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">predecessor</span><span class="p">),</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Add neighbours of point to list of checkable values.</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="k">in</span> <span class="n">next_best_node</span><span class="nf">.neighbours</span><span class="p">(</span><span class="n">blizz</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">neigh_node</span> <span class="o">=</span> <span class="nf">get_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">connections</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">estimate</span> <span class="o">=</span> <span class="n">cost_of_predecessor</span> <span class="o">+</span> <span class="nf">estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">previous_best</span> <span class="o">=</span> <span class="n">checkable</span>
                    <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="p">)</span>
                    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">))</span>
                    <span class="na">.1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">previous_best</span> <span class="o">&gt;</span> <span class="n">estimate</span> <span class="p">{</span>
                    <span class="n">checkable</span><span class="nf">.insert</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">,</span> <span class="p">(</span><span class="n">next_best_node</span><span class="nf">.pos</span><span class="p">(),</span> <span class="n">estimate</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="c1">// connections.insert(neigh_node, Some(start.pos()));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">render</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">blizzards</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Blizzard</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span>
    <span class="n">max</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">blizz</span> <span class="o">=</span> <span class="n">blizzards</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="c1">// This is a hacky way of moving the blizzard to a location but still retrieving its</span>
        <span class="c1">// location in a way that can easily be queried against the graph.</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.at_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="nf">.as_node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="py">.p</span><span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">blizz_count</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">blizz</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">blizz_last</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Blizzard</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">blizz</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="n">blizz</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">blizzards</span><span class="nf">.iter</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">curr_count</span> <span class="o">=</span> <span class="n">blizz_count</span><span class="nf">.get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">blizz_count</span><span class="nf">.insert</span><span class="p">(</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">curr_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">blizz_last</span><span class="nf">.insert</span><span class="p">(</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">min</span><span class="py">.y</span><span class="o">..=</span><span class="n">max</span><span class="py">.y</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">min</span><span class="py">.x</span><span class="o">..=</span><span class="n">max</span><span class="py">.x</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">y</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">graph</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="nf">.as_node</span><span class="p">(</span><span class="nb">None</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// This is a potential free spot. Check whether it's a blizzard or not.</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">blizz_count</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">&amp;</span><span class="mi">1</span> <span class="p">{</span>
                        <span class="c1">// Only one blizzard, print its direction.</span>
                        <span class="nd">print!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">blizz_last</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_char</span><span class="p">());</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Otherwise, print the count.</span>
                        <span class="nd">print!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// This is a free spot.</span>
                    <span class="nd">print!</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// This is a wall spot.</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Blobk until receiving return.</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.next</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="c1">// Also obtain max coords. Min coords are implicitly (1,1) for free spaces..</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">occ_map</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chars_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Tile</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"tile"</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">min</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">min_free</span> <span class="o">=</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">occ_map</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(|(</span><span class="n">point</span><span class="p">,</span> <span class="n">tile</span><span class="p">)|</span> <span class="n">point</span><span class="py">.y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tile</span> <span class="o">==</span> <span class="o">&amp;&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Tile</span><span class="p">::</span><span class="n">Free</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find start"</span><span class="p">))</span><span class="o">?</span>
        <span class="na">.0</span>
        <span class="nf">.clone</span><span class="p">()</span>
        <span class="nf">.as_node</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">occ_map</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(|(</span><span class="n">point</span><span class="p">,</span> <span class="n">tile</span><span class="p">)|</span> <span class="n">point</span><span class="py">.y</span> <span class="o">==</span> <span class="n">max</span><span class="py">.y</span> <span class="o">&amp;&amp;</span> <span class="n">tile</span> <span class="o">==</span> <span class="o">&amp;&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Tile</span><span class="p">::</span><span class="n">Free</span><span class="p">)</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot find end"</span><span class="p">))</span><span class="o">?</span>
        <span class="na">.0</span>
        <span class="nf">.clone</span><span class="p">()</span>
        <span class="nf">.as_node</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

    <span class="c1">// This isn't really a graph but we call it that because that's the name used in the other days</span>
    <span class="c1">// where the same path finding algorithm has been used.</span>
    <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">occ_map</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">point</span><span class="p">,</span> <span class="n">tile</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">tile</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="nn">Tile</span><span class="p">::</span><span class="n">Wall</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">point</span><span class="nf">.as_node</span><span class="p">(</span><span class="nb">None</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">blizzards</span> <span class="o">=</span> <span class="n">occ_map</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">point</span><span class="p">,</span> <span class="n">tile</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">data</span><span class="p">::</span><span class="nn">Tile</span><span class="p">::</span><span class="nf">Blizzard</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">=</span> <span class="n">tile</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="nn">Blizzard</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                    <span class="n">point</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">dir</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">min_free</span><span class="p">,</span>
                    <span class="n">max</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// for time in 0..10 {</span>
    <span class="c1">//     render(time, &amp;graph, &amp;blizzards, &amp;min, &amp;max);</span>
    <span class="c1">// }</span>

    <span class="k">let</span> <span class="n">estimator</span> <span class="o">=</span> <span class="p">|</span><span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">data</span><span class="p">::</span><span class="n">Point</span><span class="p">|</span> <span class="n">node</span><span class="nf">.infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blizzards</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">max_time</span> <span class="o">=</span> <span class="n">path</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="py">.p.t</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot determine path length"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"reached goal in {} steps"</span><span class="p">,</span> <span class="n">max_time</span><span class="p">);</span>

    <span class="c1">// Part 2.</span>
    <span class="c1">// Go back to the start.</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blizzards</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">max_time</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="n">max_time</span> <span class="o">=</span> <span class="n">path</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="py">.p.t</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot determine path length"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"reached start again in {} steps"</span><span class="p">,</span> <span class="n">max_time</span><span class="p">);</span>

    <span class="c1">// Go back to the end.</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">find_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blizzards</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">max_time</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="n">max_time</span> <span class="o">=</span> <span class="n">path</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="na">.0</span><span class="py">.p.t</span><span class="p">)</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot determine path length"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"reached goal again in {} steps"</span><span class="p">,</span> <span class="n">max_time</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">t</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Direction</span> <span class="p">{</span>
    <span class="n">Up</span><span class="p">,</span>
    <span class="n">Down</span><span class="p">,</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Tile</span> <span class="p">{</span>
    <span class="n">Free</span><span class="p">,</span>
    <span class="n">Wall</span><span class="p">,</span>
    <span class="nf">Blizzard</span><span class="p">(</span><span class="n">Direction</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Blizzard</span> <span class="p">{</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">,</span>
    <span class="n">min_x</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="n">min_y</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="n">max_y</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
    <span class="n">max_x</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Blizzard</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">min</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="n">max</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">start</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">start</span><span class="py">.x</span> <span class="o">-</span> <span class="n">min</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">start</span><span class="py">.y</span> <span class="o">-</span> <span class="n">min</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">direction</span><span class="p">,</span>
            <span class="n">min_x</span><span class="p">:</span> <span class="n">min</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">min_y</span><span class="p">:</span> <span class="n">min</span><span class="py">.y</span><span class="p">,</span>
            <span class="n">max_x</span><span class="p">:</span> <span class="p">(</span><span class="n">max</span><span class="py">.x</span> <span class="o">-</span> <span class="n">min</span><span class="py">.x</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">,</span>
            <span class="n">max_y</span><span class="p">:</span> <span class="p">(</span><span class="n">max</span><span class="py">.y</span> <span class="o">-</span> <span class="n">min</span><span class="py">.y</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">at_time</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">u16</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.direction</span> <span class="p">{</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Up</span> <span class="k">=&gt;</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.start.x</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="p">((</span><span class="k">self</span><span class="py">.start.y</span> <span class="k">as</span> <span class="nb">u16</span> <span class="o">+</span> <span class="k">self</span><span class="py">.max_y</span> <span class="o">-</span> <span class="n">t</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_y</span><span class="p">)</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_y</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span>
                    <span class="o">+</span> <span class="k">self</span><span class="py">.min_y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Down</span> <span class="k">=&gt;</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.start.x</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="p">((</span><span class="k">self</span><span class="py">.start.y</span> <span class="k">as</span> <span class="nb">u16</span> <span class="o">+</span> <span class="n">t</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_y</span><span class="p">)</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_y</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Left</span> <span class="k">=&gt;</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="k">self</span><span class="py">.start.x</span> <span class="k">as</span> <span class="nb">u16</span> <span class="o">+</span> <span class="k">self</span><span class="py">.max_x</span> <span class="o">-</span> <span class="n">t</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_x</span><span class="p">)</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_x</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span>
                    <span class="o">+</span> <span class="k">self</span><span class="py">.min_x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.start.y</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Right</span> <span class="k">=&gt;</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="k">self</span><span class="py">.start.x</span> <span class="k">as</span> <span class="nb">u16</span> <span class="o">+</span> <span class="n">t</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_x</span><span class="p">)</span> <span class="o">%</span> <span class="k">self</span><span class="py">.max_x</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.start.y</span> <span class="o">+</span> <span class="k">self</span><span class="py">.min_y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.direction</span> <span class="p">{</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Up</span> <span class="k">=&gt;</span> <span class="sc">'^'</span><span class="p">,</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Down</span> <span class="k">=&gt;</span> <span class="sc">'v'</span><span class="p">,</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Left</span> <span class="k">=&gt;</span> <span class="sc">'&lt;'</span><span class="p">,</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Right</span> <span class="k">=&gt;</span> <span class="sc">'&gt;'</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
            <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">env</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="n">result</span><span class="nf">.push</span><span class="p">(</span>
            <span class="c1">// Waiting.</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">result</span><span class="nf">.push</span><span class="p">(</span>
                <span class="c1">// Moving left.</span>
                <span class="k">Self</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="nf">.push</span><span class="p">(</span>
            <span class="c1">// Moving right.</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">result</span><span class="nf">.push</span><span class="p">(</span>
                <span class="c1">// Moving up.</span>
                <span class="k">Self</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="nf">.push</span><span class="p">(</span>
            <span class="c1">// Moving down.</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">t</span><span class="p">:</span> <span class="k">self</span><span class="py">.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">);</span>
        <span class="n">result</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="o">*</span><span class="k">self</span> <span class="p">};</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">time</span> <span class="p">{</span>
            <span class="n">result</span><span class="py">.p.t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="p">}</span>
        <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Direction</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"^"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Direction</span><span class="p">::</span><span class="n">Up</span><span class="p">),</span>
            <span class="s">"v"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Direction</span><span class="p">::</span><span class="n">Down</span><span class="p">),</span>
            <span class="s">"&lt;"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Direction</span><span class="p">::</span><span class="n">Left</span><span class="p">),</span>
            <span class="s">"&gt;"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Direction</span><span class="p">::</span><span class="n">Right</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot parse as tile"</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Tile</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"."</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">Free</span><span class="p">),</span>
            <span class="s">"#"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">Wall</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">Blizzard</span><span class="p">(</span><span class="n">s</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pos</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">neighbours</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">blizz</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Blizzard</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">spaces</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">occupied</span> <span class="o">=</span> <span class="n">blizz</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="n">el</span><span class="nf">.at_time</span><span class="p">(</span><span class="k">self</span><span class="py">.p.t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="c1">// Neighbours are points in the environment that are not occupied in the next turn.</span>
        <span class="k">self</span><span class="py">.p</span>
            <span class="nf">.env</span><span class="p">()</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="o">!</span><span class="n">occupied</span><span class="nf">.contains</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">spaces</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="nf">.as_node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">infinity_dist</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x_diff</span> <span class="o">=</span> <span class="k">if</span> <span class="n">other</span><span class="py">.x</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.p.x</span> <span class="p">{</span>
            <span class="n">other</span><span class="py">.x</span> <span class="o">-</span> <span class="k">self</span><span class="py">.p.x</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.p.x</span> <span class="o">-</span> <span class="n">other</span><span class="py">.x</span>
        <span class="p">}</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">y_diff</span> <span class="o">=</span> <span class="k">if</span> <span class="n">other</span><span class="py">.y</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.p.y</span> <span class="p">{</span>
            <span class="n">other</span><span class="py">.y</span> <span class="o">-</span> <span class="k">self</span><span class="py">.p.y</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.p.y</span> <span class="o">-</span> <span class="n">other</span><span class="py">.y</span>
        <span class="p">}</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="n">x_diff</span> <span class="o">+</span> <span class="n">y_diff</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">shift</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">u16</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.p.x</span><span class="p">,</span>
                <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.p.y</span><span class="p">,</span>
                <span class="n">t</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// We identify a node only by its position.</span>
<span class="k">impl</span> <span class="n">Hash</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span> <span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span><span class="nf">.hash</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.p</span> <span class="o">==</span> <span class="n">other</span><span class="py">.p</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_24">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-25">Day 25: Full of Hot Air</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect2">
<h3 id="_oveview_23">Oveview</h3>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solution_24">Solution</h3>
<div class="paragraph">
<p>This was nice in Rust by implementing two traints, <code>FromStr</code> for parsing a SNAFU
into an integer and then <code>Display</code> for converting it to string.
Parsing is straightforward.
The basic idea for displaying was to first convert to ordinary bsae 5 numbers
and then process those from least significant to most significant.
Then, for example, a <code>3</code> at one position can be replaced by a <code>=</code> at the same
position followed by incrementing the next digit by one.
The numbers 4 and 5 can be handled similarly.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PROCESSING {}"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

    <span class="c1">// Read file and convert into data.</span>
    <span class="k">let</span> <span class="n">snafus</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">parse_chunks_to_data</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">data</span><span class="p">::</span><span class="n">Snafu</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">read_lines_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
        <span class="s">"snafu"</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="nb">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">snafu</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">snafus</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} -&gt; {}"</span><span class="p">,</span> <span class="n">snafu</span><span class="nf">.dec</span><span class="p">(),</span> <span class="n">snafu</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">snafus</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">data</span><span class="p">::</span><span class="nn">Snafu</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">val</span><span class="p">|</span> <span class="n">acc</span><span class="nf">.add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"sum is {} -&gt; {}"</span><span class="p">,</span> <span class="n">sum</span><span class="nf">.dec</span><span class="p">(),</span> <span class="n">sum</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">SAMPLE1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">solve</span><span class="p">(</span><span class="n">REAL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">anyhow</span><span class="p">::{</span><span class="n">Error</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Snafu</span><span class="p">(</span><span class="nb">isize</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">Snafu</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="n">Error</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">place</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">s</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="n">place</span>
                <span class="o">*</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
                    <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="sc">'0'</span> <span class="p">|</span> <span class="sc">'1'</span> <span class="p">|</span> <span class="sc">'2'</span> <span class="k">=&gt;</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">isize</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"unknown char in snafu conversion"</span><span class="p">)),</span>
                <span class="p">};</span>
            <span class="n">place</span> <span class="o">*=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Snafu</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">dec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">isize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span> <span class="o">+</span> <span class="n">other</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">to_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">digits</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="c1">// Convert to actual base 5 first.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="k">self</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">digits</span><span class="nf">.push</span><span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">5</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Now make the conversion to snafu. Do that by replacing the digits 3, 4 and 5 by their</span>
        <span class="c1">// snafu equivalents. Do so as long as there have been incorrect digits here.</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">digits</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">digits</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">dig</span> <span class="o">@</span> <span class="mi">3</span> <span class="p">|</span> <span class="n">dig</span> <span class="o">@</span> <span class="mi">4</span> <span class="p">|</span> <span class="n">dig</span> <span class="o">@</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">digits</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dig</span> <span class="o">-</span> <span class="mi">5</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">digits</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="n">digits</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="n">digits</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// Don't do anything.</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">has_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="c1">// Now create the printable representation.</span>
        <span class="k">let</span> <span class="n">str_rep</span> <span class="o">=</span> <span class="n">digits</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.rev</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">el</span><span class="p">|</span> <span class="k">match</span> <span class="n">el</span> <span class="p">{</span>
                <span class="mi">0</span> <span class="p">|</span> <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">el</span><span class="p">),</span>
                <span class="o">-</span><span class="mi">1</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"-"</span><span class="p">),</span>
                <span class="o">-</span><span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"="</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">has_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                    <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="nf">.join</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">has_err</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span><span class="s">"cannot print snafu"</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Snafu</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.to_str</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Error</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_run_25">How to run</h3>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-11-17 23:12:30 UTC
</div>
</div>
</body>
</html>